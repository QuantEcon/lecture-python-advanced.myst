

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>16. Composite Sorting &#8212; Advanced Quantitative Economics with Python</title>
    <script src="https://unpkg.com/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://unpkg.com/tippy.js@6.3.1/dist/tippy-bundle.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
    
        <script>
            MathJax = {
            loader: {load: ['[tex]/boldsymbol', '[tex]/textmacros']},
            tex: {
                packages: {'[+]': ['boldsymbol', 'textmacros']},
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                processEscapes: true,
                macros: {
                    "argmax" : "arg\\,max",
                    "argmin" : "arg\\,min",
                    "col"    : "col",
                    "Span"   :  "span",
                    "epsilon": "\\varepsilon",
                    "EE": "\\mathbb{E}",
                    "PP": "\\mathbb{P}",
                    "RR": "\\mathbb{R}",
                    "NN": "\\mathbb{N}",
                    "ZZ": "\\mathbb{Z}",
                    "aA": "\\mathcal{A}",
                    "bB": "\\mathcal{B}",
                    "cC": "\\mathcal{C}",
                    "dD": "\\mathcal{D}",
                    "eE": "\\mathcal{E}",
                    "fF": "\\mathcal{F}",
                    "gG": "\\mathcal{G}",
                    "hH": "\\mathcal{H}",
                }
            },
            svg: {
                fontCache: 'global',
                scale: 0.92,
                displayAlign: "center",
            },
            };
        </script>
    
    
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/quantecon-book-theme.css?digest=bd0785fbb14d8d2bd4d9ae501d79ed8d3bc089ec" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/exercise.css" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.5ea377869091fd0449014c60fc090103.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>


    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/scripts/quantecon-book-theme.js?digest=d6d86bce9979111653c4c495e33499e1796e172a"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-KZLV7PM9LL"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-KZLV7PM9LL');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"argmax": "arg\\,max", "argmin": "arg\\,min", "col": "col", "Span": "span", "epsilon": "\\varepsilon", "EE": "\\mathbb{E}", "PP": "\\mathbb{P}", "RR": "\\mathbb{R}", "NN": "\\mathbb{N}", "ZZ": "\\mathbb{Z}", "aA": "\\mathcal{A}", "bB": "\\mathcal{B}", "cC": "\\mathcal{C}", "dD": "\\mathcal{D}", "eE": "\\mathcal{E}", "fF": "\\mathcal{F}", "gG": "\\mathcal{G}", "hH": "\\mathcal{H}"}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'match_transport';</script>
    <link rel="canonical" href="https://python-advanced.quantecon.org/match_transport.html" />
    <link rel="shortcut icon" href="_static/lectures-favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="17. Recursive Models of Dynamic Linear Economies" href="hs_recursive_models.html" />
    <link rel="prev" title="15. Coase’s Theory of the Firm" href="coase.html" />

<!-- Normal Meta Tags -->
<meta name="author" context="Thomas J. Sargent &amp; John Stachurski" />
<meta name="keywords" content="Python, QuantEcon, Quantitative Economics, Economics, Sloan, Alfred P. Sloan Foundation, Tom J. Sargent, John Stachurski" />
<meta name="description" content=This website presents a set of lectures on advanced quantitative economic modeling, designed and written by Thomas J. Sargent and John Stachurski. />

<!-- Twitter tags -->
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@quantecon" />
<meta name="twitter:title" content="Composite Sorting"/>
<meta name="twitter:description" content="This website presents a set of lectures on advanced quantitative economic modeling, designed and written by Thomas J. Sargent and John Stachurski.">
<meta name="twitter:creator" content="@quantecon">
<meta name="twitter:image" content="https://assets.quantecon.org/img/qe-twitter-logo.png">

<!-- Opengraph tags -->
<meta property="og:title" content="Composite Sorting" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://python-advanced.quantecon.org/match_transport.html" />
<meta property="og:image" content="https://assets.quantecon.org/img/qe-og-logo.png" />
<meta property="og:description" content="This website presents a set of lectures on advanced quantitative economic modeling, designed and written by Thomas J. Sargent and John Stachurski." />
<meta property="og:site_name" content="Advanced Quantitative Economics with Python" />
<meta name="theme-color" content="#ffffff" />

  </head>
<body>


    <span id="top"></span>

    <div class="qe-wrapper">

        <div class="qe-main">

            <div class="qe-page" id=match_transport>

                <div class="qe-page__toc">

                    <div class="inner">

                        
                        <div class="qe-page__toc-header">
                            On this page
                        </div>


                        <nav id="bd-toc-nav" class="qe-page__toc-nav">
                            <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#overview">16.1. Overview</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#setup">16.2. Setup</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#characterization-of-primal-solution">16.3. Characterization of primal solution</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#three-properties-of-an-optimal-solution">16.3.1. Three properties of an optimal solution</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#solving-a-layer">16.3.2. Solving a layer</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#solving-a-layer-in-a-smarter-way">16.3.2.1. Solving a layer in a smarter way</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solving-primal-problem">16.4. Solving primal problem</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#verify-with-linear-programming">16.4.1. Verify with linear programming</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#examples">16.5. Examples</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-1">16.5.1. Example 1</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-2">16.5.2. Example 2</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-3">16.5.3. Example 3</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#dual-solution">16.6. Dual Solution</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#application">16.7. Application</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#data">16.7.1. Data</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#model">16.7.2. Model</a></li>
</ul>
</li>
</ul>
                            <p class="logo">
                                
                                    
                                    <a href=https://quantecon.org><img src="_static/qe-logo-large.png" class="logo logo-img" alt="logo"></a>
                                    
                                    
                                
                            </p>

                            <p class="powered">Powered by <a href="https://jupyterbook.org/">Jupyter Book</a></p>

                        </nav>

                        <div class="qe-page__toc-footer">
                            
                            
                            <p><a href="#top"><strong>Back to top</strong></a></p>
                        </div>

                    </div>

                </div>

                <div class="qe-page__header">

                    <div class="qe-page__header-copy">

                        <p class="qe-page__header-heading"><a href="intro.html">Advanced Quantitative Economics with Python</a></p>

                        <p class="qe-page__header-subheading">Composite Sorting</p>

                    </div>
                    <!-- length 2, since its a string and empty dict has length 2 - {} -->
                        <p class="qe-page__header-authors" font-size="18">
                            
                                
                                    <a href="http://www.tomsargent.com/" target="_blank"><span>Thomas J. Sargent</span></a>
                                
                            
                                
                                    and <a href="https://johnstachurski.net/" target="_blank"><span>John Stachurski</span></a>
                                
                            
                        </p>


                </div> <!-- .page__header -->



                
                <main class="qe-page__content" role="main">
                    
                    <div>
                        
  <section class="tex2jax_ignore mathjax_ignore" id="composite-sorting">
<h1><span class="section-number">16. </span>Composite Sorting<a class="headerlink" href="#composite-sorting" title="Permalink to this heading">#</a></h1>
<section id="overview">
<h2><span class="section-number">16.1. </span>Overview<a class="headerlink" href="#overview" title="Permalink to this heading">#</a></h2>
<p>Optimal transport theory is studies how one (marginal) probabilty measure can be related to another (marginal) probability measure in an ideal way.</p>
<p>The output of such a theory is a <strong>coupling</strong> of the two probability measures, i.e., a joint probabilty
measure having those two  marginal probability measures.</p>
<p>This lecture describes how Job Boerma, Aleh Tsyvinski, Ruodo Wang,
and Zhenyuan Zhang  <span id="id1">[<a class="reference internal" href="zreferences.html#id3" title="Job Boerma, Aleh Tsyvinski, Ruodu Wang, and Zhenyuan Zhang. Composite sorting. Technical Report, University of Wisconsin, 2024.">Boerma <em>et al.</em>, 2024</a>]</span> used optimal transport theory to formulate and solve an equilibrium of a model in which wages and allocations of workers across jobs  adjust to match measures of  different types with measures of different types of occupations.</p>
<p>Production technologies allow firms to affect  shape costs of mismatch with the consequence
that costs of mismatch can be concave.</p>
<p>That means that it possible that equilibrium there is neither <strong>positive assortive</strong> nor <strong>negative assorting</strong>  matching, an outcome that   <span id="id2">[<a class="reference internal" href="zreferences.html#id3" title="Job Boerma, Aleh Tsyvinski, Ruodu Wang, and Zhenyuan Zhang. Composite sorting. Technical Report, University of Wisconsin, 2024.">Boerma <em>et al.</em>, 2024</a>]</span> call <strong>composite assortive</strong> matching.</p>
<p>For example, in  an equilibrium with composite matching,  identical <strong>workers</strong> can sort into different <strong>occupations</strong>, some positively and some negatively.</p>
<p><span id="id3">[<a class="reference internal" href="zreferences.html#id3" title="Job Boerma, Aleh Tsyvinski, Ruodu Wang, and Zhenyuan Zhang. Composite sorting. Technical Report, University of Wisconsin, 2024.">Boerma <em>et al.</em>, 2024</a>]</span>
show how this can generate distinct distributions  of labor earnings  within and across occupations.</p>
<p>This lecture describes the <span id="id4">[<a class="reference internal" href="zreferences.html#id3" title="Job Boerma, Aleh Tsyvinski, Ruodu Wang, and Zhenyuan Zhang. Composite sorting. Technical Report, University of Wisconsin, 2024.">Boerma <em>et al.</em>, 2024</a>]</span> model and  presents  Python code for computing equilibria.</p>
<p>The lecture  applies the code to the <span id="id5">[<a class="reference internal" href="zreferences.html#id3" title="Job Boerma, Aleh Tsyvinski, Ruodu Wang, and Zhenyuan Zhang. Composite sorting. Technical Report, University of Wisconsin, 2024.">Boerma <em>et al.</em>, 2024</a>]</span> model of labor markets.</p>
<p>As with an earlier QuantEcon lecture on optimal transport (<a class="reference external" href="https://python.quantecon.org/opt_transport.html">https://python.quantecon.org/opt_transport.html</a>), a key tool will be <strong>linear programming</strong>.</p>
</section>
<section id="setup">
<h2><span class="section-number">16.2. </span>Setup<a class="headerlink" href="#setup" title="Permalink to this heading">#</a></h2>
<p><span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> are finite sets that represent two distinct types of people to be matched.</p>
<p>For each <span class="math notranslate nohighlight">\(x \in X,\)</span> let a positive integer <span class="math notranslate nohighlight">\(n_x\)</span> be the number  of agents of type <span class="math notranslate nohighlight">\(x\)</span>.</p>
<p>Similarly, let a positive integer <span class="math notranslate nohighlight">\(m_y\)</span> be the agents of agents of type <span class="math notranslate nohighlight">\(y \in Y\)</span>.</p>
<p>We refer to these two measures as <em>marginals</em>.</p>
<p>We assume that</p>
<div class="math notranslate nohighlight">
\[
\sum_{x \in X} n_x = \sum_{y \in Y} m_y  =: N
\]</div>
<p>so that  the matching  problem is <em>balanced</em>.</p>
<p>Given a <em>cost function</em> <span class="math notranslate nohighlight">\(c:X \times Y \rightarrow \mathbb{R}\)</span>, the (discrete) <em>optimal transport problem</em> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\min_{\mu \geq 0}&amp; \sum_{(x,y) \in X \times Y} \mu_{xy}c_{xy} \\
\text{s.t. }&amp; \sum_{x \in X} \mu_{xy} = n_x \\
&amp; \sum_{y \in Y} \mu_{xy} = m_y 
\end{aligned}
\end{split}\]</div>
<p>Given our discreteness  assumptions about <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(m\)</span>, the problem admits an integer solution <span class="math notranslate nohighlight">\(\mu \in \mathbb{Z}_+^{X \times Y}\)</span>, i.e. <span class="math notranslate nohighlight">\(\mu_{xy}\)</span> is a non-negative integer for each <span class="math notranslate nohighlight">\(x\in X, y\in Y\)</span>.</p>
<p>We will study integer solutions.</p>
<p>Two points about restricting ourselves to integer solutions are worth mentioning:</p>
<ul class="simple">
<li><p>it is without loss of generality for computational purposes, since every problem with float marginals can be transformed into an equivalent problem with integer marginals;</p></li>
<li><p>although the mathematical structure that we present actually   wors for arbitrary real marginals, some of our Python  implementations would  fail to work with float arithmetic.</p></li>
</ul>
<p>We focus on  a specific instance of an  optimal transport problem:</p>
<p>We assume that <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> are finite subsets of <span class="math notranslate nohighlight">\(\mathbb{R}\)</span> and that the cost function satisfies <span class="math notranslate nohighlight">\(c_{xy} = h(|x - y|)\)</span> for all <span class="math notranslate nohighlight">\(x,y \in \mathbb{R},\)</span> for an <span class="math notranslate nohighlight">\(h: \mathbb{R}_+ \rightarrow \mathbb{R}_+\)</span> that  is <strong>strictly concave</strong> and <strong>strictly increasing</strong> and <strong>grounded</strong> (i.e., <span class="math notranslate nohighlight">\(h(0)=0\)</span>).</p>
<p>Such an  <span class="math notranslate nohighlight">\(h\)</span> satisfies the following</p>
<p><strong>Lemma.</strong> Let <span class="math notranslate nohighlight">\(h: \mathbb{R}_+ \rightarrow \mathbb{R}_+\)</span> be <strong>strictly concave</strong> and <strong>grounded</strong>. Then <span class="math notranslate nohighlight">\(h\)</span> is strictly subadditive, i.e. for all <span class="math notranslate nohighlight">\(x,y\in \mathbb{R}_+, 0&lt; x &lt; y,\)</span> we have</p>
<div class="math notranslate nohighlight">
\[
h(x+y) &lt; h(x) + h(y)
\]</div>
<p><em>Proof.</em> For <span class="math notranslate nohighlight">\(\alpha \in (0,1)\)</span> and <span class="math notranslate nohighlight">\(x &gt;0\)</span> we have, by strict concavity and groundedness, <span class="math notranslate nohighlight">\(h(\alpha x) &gt; \alpha h(x) + (1-\alpha) h(0)=\alpha h(x). \)</span></p>
<p>Now fix <span class="math notranslate nohighlight">\(x,y\in \mathbb{R}_+, 0&lt; x &lt; y,\)</span> and let <span class="math notranslate nohighlight">\(\alpha = \frac{x}{x+y};\)</span> the previous observation gives <span class="math notranslate nohighlight">\(h(x) = h(\alpha (x+y)) &gt; \alpha h(x+y)\)</span> and <span class="math notranslate nohighlight">\(h(y) = h((1-\alpha) (x+y)) &gt; (1-\alpha) h(x+y) \)</span>;  summing  these inequality delivers the result. <span class="math notranslate nohighlight">\(\square\)</span></p>
<p>In the following implementation we assume that the cost function is <span class="math notranslate nohighlight">\(c_{xy} = |x-y|^{1/\zeta}\)</span> for <span class="math notranslate nohighlight">\(\zeta&gt;1,\)</span> i.e. <span class="math notranslate nohighlight">\(h(z) =  z^{1/\zeta}\)</span> for <span class="math notranslate nohighlight">\(z \in \mathbb{R}_+.\)</span></p>
<p>Hence, our problem is</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\min_{\mu \in \mathbb{Z}_+^{X \times Y}}&amp; \sum_{(x,y) \in X \times Y} \mu_{xy}|x-y|^{1/\zeta} \\
\text{s.t. }&amp; \sum_{x \in X} \mu_{xy} = n_x \\
&amp; \sum_{y \in Y} \mu_{xy} = m_y 
\end{aligned}
\end{split}\]</div>
<p>Let’s start setting up some Python code.</p>
<p>We  use the following imports:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">linprog</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>


<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">patches</span>
<span class="kn">from</span> <span class="nn">matplotlib.ticker</span> <span class="kn">import</span> <span class="n">MaxNLocator</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">Normalize</span>
</pre></div>
</div>
</div>
</div>
<p>The following Python class takes as inputs sets of types <span class="math notranslate nohighlight">\(X,Y \subset \mathbb{R},\)</span> marginals <span class="math notranslate nohighlight">\(n, m \)</span> with positive integer entries such that <span class="math notranslate nohighlight">\(\sum_{x \in X} n_x = \sum_{y \in Y} m_y \)</span> and cost parameter <span class="math notranslate nohighlight">\(\zeta&gt;1\)</span>.</p>
<p>The cost function is stored as an <span class="math notranslate nohighlight">\(|X| \times |Y|\)</span> matrix with <span class="math notranslate nohighlight">\((x,y)\)</span>-entry equal to <span class="math notranslate nohighlight">\(|x-y|^{1/\zeta},\)</span> i.e., the cost of matching an agent of type <span class="math notranslate nohighlight">\(x \in X\)</span> with an agent of type <span class="math notranslate nohighlight">\(y \in Y.\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ConcaveCostOT</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Y_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_x</span> <span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">m_y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ζ</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        
        <span class="c1"># Sets of types </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span> <span class="o">=</span> <span class="n">X_types</span><span class="p">,</span> <span class="n">Y_types</span>
        
        <span class="c1"># Marginals</span>
        <span class="k">if</span> <span class="n">X_types</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Y_types</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">non_empty_types</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_types</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="k">if</span> <span class="n">n_x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">n_x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">m_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Y_types</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="k">if</span> <span class="n">m_y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">m_y</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">non_empty_types</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_y</span> <span class="o">=</span> <span class="n">n_x</span><span class="p">,</span> <span class="n">m_y</span>

        <span class="c1"># Cost function: |X|x|Y| matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ζ</span> <span class="o">=</span> <span class="n">ζ</span>
        <span class="k">if</span> <span class="n">non_empty_types</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cost_x_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">X_types</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">Y_types</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span> \
            <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">ζ</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cost_x_y</span> <span class="o">=</span> <span class="kc">None</span> 
</pre></div>
</div>
</div>
</div>
<p>Let’s consider a random instance with given numbers of types <span class="math notranslate nohighlight">\(|X|\)</span> and <span class="math notranslate nohighlight">\(|Y|\)</span> and a given number of agents.</p>
<p>First, we generate random types <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y.\)</span></p>
<p>Then we generate random quantities for each type so that there are <span class="math notranslate nohighlight">\(N\)</span> agents for each side.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">number_of_x_types</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">number_of_y_types</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">N_agents_per_side</span> <span class="o">=</span> <span class="mi">60</span>

<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">## Genetate random types</span>
<span class="c1"># generate random support for distributions of types</span>
<span class="n">support_size</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">random_support</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">support_size</span><span class="p">))</span>

<span class="c1"># generate types</span>
<span class="n">X_types_example</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">random_support</span><span class="p">,</span> 
                    <span class="n">size</span><span class="o">=</span><span class="n">number_of_x_types</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">Y_types_example</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">random_support</span><span class="p">,</span> 
                    <span class="n">size</span><span class="o">=</span><span class="n">number_of_y_types</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1">## Generate random integer types quantities summing to N_agents_per_side</span>

<span class="c1"># generate integer vectors of lenght n_types summing to n_agents</span>
<span class="k">def</span> <span class="nf">random_marginal</span><span class="p">(</span><span class="n">n_types</span><span class="p">,</span> <span class="n">n_agents</span><span class="p">):</span>
    <span class="n">cuts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n_agents</span><span class="p">),</span> 
                                    <span class="n">size</span><span class="o">=</span> <span class="n">n_types</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
    <span class="n">segments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">cuts</span><span class="p">,</span> <span class="p">[</span><span class="n">n_agents</span><span class="p">])))</span>
    <span class="k">return</span> <span class="n">segments</span>

<span class="c1"># Create a method to assign random marginals to our class</span>
<span class="k">def</span> <span class="nf">assign_random_marginals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">random_seed</span><span class="p">):</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span> <span class="o">=</span> <span class="n">random_marginal</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">),</span> <span class="n">N_agents_per_side</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">m_y</span> <span class="o">=</span> <span class="n">random_marginal</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">),</span> <span class="n">N_agents_per_side</span><span class="p">)</span>

<span class="n">ConcaveCostOT</span><span class="o">.</span><span class="n">assign_random_marginals</span> <span class="o">=</span> <span class="n">assign_random_marginals</span>

<span class="c1"># Create an instance of our class and generate random marginals</span>
<span class="n">example_pb</span> <span class="o">=</span> <span class="n">ConcaveCostOT</span><span class="p">(</span><span class="n">X_types_example</span><span class="p">,</span> <span class="n">Y_types_example</span><span class="p">,</span> <span class="n">ζ</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">example_pb</span><span class="o">.</span><span class="n">assign_random_marginals</span><span class="p">(</span><span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<!-- We will use  $f$ (resp. $g$) to denote the probability mass function associated to the measure $n$ (resp. $m$) and with $F$ (resp. $G$) the corresponding cumulative distribution function.

Thus, $f(x) =\frac{n_x}{N} \mathbb{1}\{n_x > 0\} $ and $g(y) =\frac{m_y}{N} \mathbb{1}\{m_y > 0\} $ for $x,y \in \mathbb{R}.$  -->
<p>We use  <span class="math notranslate nohighlight">\(F\)</span> (resp. <span class="math notranslate nohighlight">\(G\)</span>) to denote the cumulative distribution function associated to the measure <span class="math notranslate nohighlight">\(n\)</span> (resp. <span class="math notranslate nohighlight">\(m\)</span>)</p>
<p>Thus, <span class="math notranslate nohighlight">\(F(z) =\sum_{x \leq z: n_x &gt; 0} n_x \)</span> and <span class="math notranslate nohighlight">\(G(z) =\sum_{y \leq z: m_y &gt; 0} m_y \)</span> for <span class="math notranslate nohighlight">\(z\in \mathbb{R}.\)</span></p>
<p>Notice that we not normalizing the measures so <span class="math notranslate nohighlight">\(F(\infty) = G(\infty) =N.\)</span></p>
<p>The following method plots the marginals on the real line</p>
<ul class="simple">
<li><p>blue for <span class="math notranslate nohighlight">\(X\)</span> types,</p></li>
<li><p>red for <span class="math notranslate nohighlight">\(Y\)</span> types.</p></li>
</ul>
<p>Note that there are possible overlaps between <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y.\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_marginals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Distributions of types&#39;</span><span class="p">):</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
    
    <span class="c1"># Scatter plot n_x</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;n_x&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> 
               <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">)</span>
    
    <span class="c1"># Scatter plot m_y</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">,</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;m_y&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=-</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_y</span><span class="p">,</span> 
               <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">)</span>

    <span class="c1"># Add grid and y=0 axis</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">((</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c1"># Labeling the axes and the title</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;frequency&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
<span class="n">ConcaveCostOT</span><span class="o">.</span><span class="n">plot_marginals</span> <span class="o">=</span> <span class="n">plot_marginals</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">example_pb</span><span class="o">.</span><span class="n">plot_marginals</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ec2594a380867b53dec7102ebf60b2f9d59730f3934493e31115afe5070dcdf7.png" src="_images/ec2594a380867b53dec7102ebf60b2f9d59730f3934493e31115afe5070dcdf7.png" />
</div>
</div>
</section>
<section id="characterization-of-primal-solution">
<h2><span class="section-number">16.3. </span>Characterization of primal solution<a class="headerlink" href="#characterization-of-primal-solution" title="Permalink to this heading">#</a></h2>
<section id="three-properties-of-an-optimal-solution">
<h3><span class="section-number">16.3.1. </span>Three properties of an optimal solution<a class="headerlink" href="#three-properties-of-an-optimal-solution" title="Permalink to this heading">#</a></h3>
<p>We now indicate important properties that  are satisfied by an optimal solution.</p>
<ol class="arabic simple">
<li><p>Maximal number of perfect pairs</p></li>
<li><p>No intersecting pairs</p></li>
<li><p>Layering</p></li>
</ol>
<p><strong>(Maximal number of perfect pairs)</strong></p>
<p>If <span class="math notranslate nohighlight">\((z,z) \in X \times Y\)</span> for some <span class="math notranslate nohighlight">\(z \in \mathbb{R}\)</span> then in each optimal solution there are <span class="math notranslate nohighlight">\(\min\{n_z,m_z\}\)</span> matches between type <span class="math notranslate nohighlight">\(z \in X\)</span> and <span class="math notranslate nohighlight">\(z \in Y\)</span>.</p>
<p>Indeed, assume by contradiction that at an optimal solution we have <span class="math notranslate nohighlight">\((z,y)\)</span> and <span class="math notranslate nohighlight">\((x,z)\)</span> matched in positive amounts for <span class="math notranslate nohighlight">\(y,x \neq z\)</span>.</p>
<p>We can verify that reassigning the minimum of such quantities to the pairs <span class="math notranslate nohighlight">\((z,z)\)</span> and <span class="math notranslate nohighlight">\((x,y)\)</span> improves upon the current matching since</p>
<div class="math notranslate nohighlight">
\[
h(|x-y|) \leq h(|x-z| +|z - y|) &lt; h(|x-z|)+ h(|z - y|)
\]</div>
<p>where the first inequality follows from triangle inequality and the fact that <span class="math notranslate nohighlight">\(h\)</span> is increasing and the strict inequality from strict subadditivity.</p>
<p>We can then repeat the operation for any other analogous pair of matches involving <span class="math notranslate nohighlight">\(z,\)</span> while improving  the value, until we have  mass <span class="math notranslate nohighlight">\(\min\{n_z,m_z\}\)</span> on  match <span class="math notranslate nohighlight">\((z,z).\)</span></p>
<p>Viewing the matching <span class="math notranslate nohighlight">\(\mu\)</span> as a measure on <span class="math notranslate nohighlight">\(X \times Y\)</span> with marginals <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(m\)</span>, this property says that in any optimal <span class="math notranslate nohighlight">\(\mu\)</span> we have <span class="math notranslate nohighlight">\(\mu_{zz} = n_z \wedge m_z\)</span> for <span class="math notranslate nohighlight">\((z,z)\)</span> in the diagonal <span class="math notranslate nohighlight">\(\{(x,y) \in X \times Y: x=y\}\)</span> of <span class="math notranslate nohighlight">\(\mathbb{R} \times \mathbb{R}\)</span>.</p>
<p>The following method finds perfect pairs and returns the on-diagonal matchings as well as the residual off-diagonal marginals.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">match_perfect_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="c1"># Find pairs on diagonal and related mass</span>
    <span class="n">perfect_pairs_x</span><span class="p">,</span> <span class="n">perfect_pairs_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">[</span><span class="kc">None</span><span class="p">,:])</span>
    <span class="n">Δ_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="p">[</span><span class="n">perfect_pairs_x</span><span class="p">]</span> <span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">m_y</span><span class="p">[</span><span class="n">perfect_pairs_y</span><span class="p">])</span>

    <span class="c1"># Compute off-diagonal residual masses for each side</span>
    <span class="n">n_x_off_diag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">n_x_off_diag</span><span class="p">[</span><span class="n">perfect_pairs_x</span><span class="p">]</span><span class="o">-=</span> <span class="n">Δ_q</span>

    <span class="n">m_y_off_diag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">m_y_off_diag</span><span class="p">[</span><span class="n">perfect_pairs_y</span><span class="p">]</span> <span class="o">-=</span> <span class="n">Δ_q</span>

    <span class="c1"># Compute on-diagonal matching</span>
    <span class="n">matching_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">matching_diag</span><span class="p">[</span><span class="n">perfect_pairs_x</span><span class="p">,</span> <span class="n">perfect_pairs_y</span><span class="p">]</span> <span class="o">=</span> <span class="n">Δ_q</span>
    
    <span class="k">return</span> <span class="n">n_x_off_diag</span><span class="p">,</span> <span class="n">m_y_off_diag</span> <span class="p">,</span> <span class="n">matching_diag</span>

<span class="n">ConcaveCostOT</span><span class="o">.</span><span class="n">match_perfect_pairs</span> <span class="o">=</span> <span class="n">match_perfect_pairs</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n_x_off_diag</span><span class="p">,</span> <span class="n">m_y_off_diag</span> <span class="p">,</span> <span class="n">matching_diag</span> <span class="o">=</span> <span class="n">example_pb</span><span class="o">.</span><span class="n">match_perfect_pairs</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;On-diagonal matches: </span><span class="si">{</span><span class="n">matching_diag</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Residual types in X: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">n_x_off_diag</span><span class="p">[</span><span class="n">n_x_off_diag</span><span class="w"> </span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Residual types in Y: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">m_y_off_diag</span><span class="p">[</span><span class="n">m_y_off_diag</span><span class="w"> </span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>On-diagonal matches: 15
Residual types in X: 14
Residual types in Y: 16
</pre></div>
</div>
</div>
</div>
<p>We can therefore create a new instance with the residual marginals that will feature no perfect pairs.</p>
<p>Later we shall   add the on-diagonal matching to the solution of this new instance.</p>
<p>We refer to this instance as “off-diagonal” since the product measure of the residual marginals <span class="math notranslate nohighlight">\(n \otimes m\)</span> feature zeros mass on the diagonal of <span class="math notranslate nohighlight">\(\mathbb{R} \times \mathbb{R}.\)</span></p>
<p>In the rest of this section, we will focus on  this instance.</p>
<p>We create a subclass to study the residual off-diagonal problem.</p>
<p>The subclass inherits the attributes and the modules from the original class.</p>
<p>We let <span class="math notranslate nohighlight">\(Z := X \sqcup Y ,\)</span> where <span class="math notranslate nohighlight">\(\sqcup\)</span> denotes the union of disjoint sets. We will</p>
<ul class="simple">
<li><p>index types <span class="math notranslate nohighlight">\(X\)</span> as <span class="math notranslate nohighlight">\(\{0, \dots,|X|-1\}\)</span> and types <span class="math notranslate nohighlight">\(Y\)</span> as <span class="math notranslate nohighlight">\(\{|X|, \dots,|X| + |Y|-1\};\)</span></p></li>
<li><p>store the cost function as a <span class="math notranslate nohighlight">\(|Z| \times |Z|\)</span> matrix with entry <span class="math notranslate nohighlight">\((z,z')\)</span> equal to <span class="math notranslate nohighlight">\(c_{xy}\)</span> if <span class="math notranslate nohighlight">\(z=x \in X\)</span> and <span class="math notranslate nohighlight">\(z' =y\in Y\)</span> or <span class="math notranslate nohighlight">\(z=y \in Y\)</span> and <span class="math notranslate nohighlight">\(z' =x\in X\)</span> or equal to <span class="math notranslate nohighlight">\(+\infty\)</span> if <span class="math notranslate nohighlight">\(z\)</span> and <span class="math notranslate nohighlight">\(z'\)</span> belong to the same side</p>
<ul>
<li><p>(the latter is just customary, since these “infinitely penalized” entries are actually never accessed in the implementation);</p></li>
</ul>
</li>
<li><p>let <span class="math notranslate nohighlight">\(q\)</span> be a vector of size <span class="math notranslate nohighlight">\(|Z|\)</span> whose <span class="math notranslate nohighlight">\(z\)</span>-th entry equals <span class="math notranslate nohighlight">\(n_x\)</span> if type <span class="math notranslate nohighlight">\(x\)</span> is the <span class="math notranslate nohighlight">\(z\)</span>-th smallest type in <span class="math notranslate nohighlight">\(Z\)</span> and <span class="math notranslate nohighlight">\(-m_y\)</span> if type <span class="math notranslate nohighlight">\(y\)</span> is the <span class="math notranslate nohighlight">\(z\)</span>-th smallest type in <span class="math notranslate nohighlight">\(Z\)</span>; hence <span class="math notranslate nohighlight">\(q\)</span> encodes capacities of both sides on the (ascending) sorted set of types.</p></li>
</ul>
<p>Finally, we add a method to flexibly add a pair <span class="math notranslate nohighlight">\((i,j)\)</span> with <span class="math notranslate nohighlight">\(i \in \{0, \dots,|X|-1\},j \in \{|X|, \dots,|X| + |Y|-1\}\)</span> or <span class="math notranslate nohighlight">\(j \in \{0, \dots,|X|-1\},i \in \{|X|, \dots,|X| + |Y|-1\}\)</span> to a matching matrix of size <span class="math notranslate nohighlight">\(|X| \times |Y|\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">OffDiagonal</span><span class="p">(</span><span class="n">ConcaveCostOT</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_types</span><span class="p">,</span> <span class="n">Y_types</span><span class="p">,</span> <span class="n">n_x</span><span class="p">,</span> <span class="n">m_y</span><span class="p">,</span> <span class="n">ζ</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">X_types</span><span class="p">,</span> <span class="n">Y_types</span><span class="p">,</span> <span class="n">n_x</span><span class="p">,</span> <span class="n">m_y</span><span class="p">,</span> <span class="n">ζ</span><span class="p">)</span>

        <span class="c1"># Types (unsorted)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X_types</span><span class="p">,</span><span class="n">Y_types</span><span class="p">))</span>

        <span class="c1"># Cost function: |Z|x|Z| matrix </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost_z_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">types_list</span><span class="p">),</span>
                                 <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">types_list</span><span class="p">)))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="c1"># upper-right block</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost_z_z</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">):]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_x_y</span> 
        
        <span class="c1"># lower-left block</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost_z_z</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">):,</span> <span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_x_y</span><span class="o">.</span><span class="n">T</span>

        <span class="c1">## Distributions of types</span>
        <span class="c1"># sorted types and index identifier for each z in support</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">types_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">support_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">types_list</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">type_z</span><span class="p">]</span>

        <span class="c1"># signed quantity for each type z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">n_x</span><span class="p">,</span> <span class="o">-</span> <span class="n">m_y</span><span class="p">])[</span><span class="bp">self</span><span class="o">.</span><span class="n">type_z</span><span class="p">]</span> 

    <span class="c1"># Mathod that adds to matching matrix a pair (i,j)</span>
    <span class="k">def</span> <span class="nf">add_pair_to_matching</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pair_ids</span><span class="p">,</span> <span class="n">matching</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pair_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pair_ids</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># the pair of indices correspond to a pair (x,y)</span>
            <span class="n">matching</span><span class="p">[</span><span class="n">pair_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pair_ids</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># the pair of indices correspond to a pair (y,x)</span>
            <span class="n">matching</span><span class="p">[</span><span class="n">pair_ids</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pair_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>  
</pre></div>
</div>
</div>
</div>
<p>We add a function that returns an instance of the off-diagonal subclass as well as the on-diagonal matching and the indices of the residual off-diagonal types.</p>
<p>These indices will come handy for adding the off-diagonal matching matrix to the diagonal matching matrix we just found, since the former will have a smaller size if there are perfect pairs in the original problem.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_offD_onD_matching</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Match perfect pairs and compute on-diagonal matching</span>
    <span class="n">n_x_off_diag</span><span class="p">,</span> <span class="n">m_y_off_diag</span> <span class="p">,</span> <span class="n">matching_diag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_perfect_pairs</span><span class="p">()</span>

    <span class="c1"># Find indices of residual non-zero quantities for each side</span>
    <span class="n">nonzero_id_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">n_x_off_diag</span><span class="p">)</span>
    <span class="n">nonzero_id_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">m_y_off_diag</span><span class="p">)</span>

    <span class="c1"># Create new instance with off-diagonal types</span>
    <span class="n">off_diagonal</span> <span class="o">=</span> <span class="n">OffDiagonal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">[</span><span class="n">nonzero_id_x</span><span class="p">],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">[</span><span class="n">nonzero_id_y</span><span class="p">],</span> 
                                    <span class="n">n_x_off_diag</span><span class="p">[</span><span class="n">nonzero_id_x</span><span class="p">],</span> 
                                    <span class="n">m_y_off_diag</span><span class="p">[</span><span class="n">nonzero_id_y</span><span class="p">],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">ζ</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">off_diagonal</span><span class="p">,</span> <span class="p">(</span><span class="n">nonzero_id_x</span><span class="p">,</span> <span class="n">nonzero_id_y</span><span class="p">,</span> <span class="n">matching_diag</span><span class="p">)</span>

<span class="n">ConcaveCostOT</span><span class="o">.</span><span class="n">generate_offD_onD_matching</span> <span class="o">=</span> <span class="n">generate_offD_onD_matching</span>
</pre></div>
</div>
</div>
</div>
<p>We apply it to our example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">example_off_diag</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">example_pb</span><span class="o">.</span><span class="n">generate_offD_onD_matching</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s plot the residual marginals to verify visually that there are no overlappings between types from distinct sides in the off-diagonal instance.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">example_off_diag</span><span class="o">.</span><span class="n">plot_marginals</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;Distributions of types: off-diagonal&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/3b71bec78f1535d6eafac6d37c0c51311f6fea73b835d3dbb20fa111e7c3f214.png" src="_images/3b71bec78f1535d6eafac6d37c0c51311f6fea73b835d3dbb20fa111e7c3f214.png" />
</div>
</div>
<p><strong>(No intersecting pairs)</strong> This  property summarizes  the following fact:</p>
<ul class="simple">
<li><p>represent both types  on the real line and draw a semicirle joining <span class="math notranslate nohighlight">\((x,y)\)</span> for all pairs <span class="math notranslate nohighlight">\((x,y) \in X \times Y\)</span> that are matched in a solution</p></li>
<li><p>these semicirles do not intersect (unless they share one of the endpoints).</p></li>
</ul>
<p>A proof proceeds by contradiction.</p>
<p>Let’s consider types <span class="math notranslate nohighlight">\(x,x' \in X\)</span> and <span class="math notranslate nohighlight">\(y,y' \in Y.\)</span></p>
<p>Matched pairs cain “intersect” (or be  tangent).</p>
<p>We will show that in both cases the partial matching among types <span class="math notranslate nohighlight">\(x,x',y,y'\)</span> can be improved by <em>uncrossing</em>, i.e. reassigning the quantities while improving on the solution and reducing the number of intersecting pairs.</p>
<p>The first case of intersecting pairs is</p>
<div class="math notranslate nohighlight">
\[ 
x &lt; y &lt; y' &lt; x'
\]</div>
<p>with pairs <span class="math notranslate nohighlight">\((x,y')\)</span> and <span class="math notranslate nohighlight">\((x',y)\)</span> matched in positive quantities.</p>
<p>Then it follows from strict monotonicity of <span class="math notranslate nohighlight">\(h\)</span> that <span class="math notranslate nohighlight">\(h(|x-y|) &lt; h(|x-y'|)\)</span> and <span class="math notranslate nohighlight">\(h(|x'-y'|) &lt; h(|x'-y|),\)</span> hence <span class="math notranslate nohighlight">\(h(|x-y|)+ h(|x'-y'|) &lt; h(|x-y'|) + h(|x'-y|).\)</span></p>
<p>Therefore, we can take the minimum of the masses of the matched pairs <span class="math notranslate nohighlight">\((x,y')\)</span> and <span class="math notranslate nohighlight">\((x',y)\)</span> and  reallocate it to the pairs <span class="math notranslate nohighlight">\((x,y)\)</span> and <span class="math notranslate nohighlight">\((x',y')\)</span>,
therby  strictly improving the cost among <span class="math notranslate nohighlight">\(x,y,x',y'.\)</span></p>
<p>The second case of intersecting pairs is</p>
<div class="math notranslate nohighlight">
\[
x &lt; x' &lt; y' &lt; y
\]</div>
<p>with pairs <span class="math notranslate nohighlight">\((x,y')\)</span> and <span class="math notranslate nohighlight">\((x',y)\)</span> matched.</p>
<p>In this case we have</p>
<div class="math notranslate nohighlight">
\[
|x - y'| + |x' - y| = |x - y| + |x' - y'|
\]</div>
<p>Letting <span class="math notranslate nohighlight">\(\alpha := \frac{|x - y|+|x' - y|}{|x - y'| - |x' - y|} \in (0,1),\)</span> we have <span class="math notranslate nohighlight">\(|x - y| = \alpha|x - y'| +(1-\alpha) |x' - y| \)</span> and <span class="math notranslate nohighlight">\(|x' - y'| = (1-\alpha)|x - y'| +\alpha |x' - y|. \)</span></p>
<p>Hence, by strict concavity of <span class="math notranslate nohighlight">\(h,\)</span></p>
<div class="math notranslate nohighlight">
\[
h(|x-y|)+ h(|x'-y'|) &lt;\alpha h(|x - y'|) +(1-\alpha) h(|x' - y|) +  (1-\alpha) h(|x - y'|) +\alpha h(|x' - y|) = h(|x-y'|) + h(|x'-y|).
\]</div>
<p>Therefore, as in the first case, we can strictly improve the cost among <span class="math notranslate nohighlight">\(x,y,x',y'\)</span> by uncrossing the pairs.</p>
<p>Finally, it remains to argue that in both cases  <em>uncrossing</em> operations do not increase the number of intersections with other matched pairs.</p>
<p>It can indeed be shown on a case-by-case basis that, in both of the above cases, for any other matched pair <span class="math notranslate nohighlight">\((x'',y'')\)</span> the number of intersections between pairs <span class="math notranslate nohighlight">\((x,y), (x',y')\)</span> and the pair <span class="math notranslate nohighlight">\((x'',y'')\)</span> (i.e., after uncrossing) is not larger than the number of intersections between pairs <span class="math notranslate nohighlight">\((x,y'), (x',y)\)</span> and the pair <span class="math notranslate nohighlight">\((x'',y'')\)</span> (i.e., before uncrossing), hence the uncrossing operations above reduce the number of intersections.</p>
<p>We conclude that if a matching features intersecting pairs, it can be modified via a sequence of uncrossing operations into a matching without intersecting pairs while improving on the value.</p>
<p><strong>(Layering)</strong> Recall that there are <span class="math notranslate nohighlight">\(2N\)</span> individual agents, each agent <span class="math notranslate nohighlight">\(i\)</span> having type <span class="math notranslate nohighlight">\(z_i \in X \sqcup Y.\)</span></p>
<p>When we introduce the off diagonal matching, to stress that the types sets are disjoint now.</p>
<p>To simplify our explanation  of this property, assume for now that each agent has its own distinct type (i.e., |X|=|Y| =N and <span class="math notranslate nohighlight">\(n=m= \mathbf{1}_N\)</span>), in which case the optimal transport problem is also referred to as <em>assignment problem</em>.</p>
<p>Let’s index  agents according to their types:</p>
<div class="math notranslate nohighlight">
\[
z_1 &lt; z_2 \dots&lt;  z_{2N-1} &lt; z_{2N}.
\]</div>
<p>Suppose that agents <span class="math notranslate nohighlight">\(i\)</span> of type <span class="math notranslate nohighlight">\(z_i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> of type <span class="math notranslate nohighlight">\(z_j\)</span>, with <span class="math notranslate nohighlight">\(z_i &lt; z_j,\)</span> are matched in a particular optimal solution.</p>
<p>Then there is an equal number of agents from each side in <span class="math notranslate nohighlight">\(\{i+1, \dots, j-1\},\)</span> if this set is not empty.</p>
<p>Indeed, if this were not the case, then some agent <span class="math notranslate nohighlight">\(k \in \{i+1,j-1\}\)</span> would be  matched with some agent <span class="math notranslate nohighlight">\(\ell\)</span> with <span class="math notranslate nohighlight">\(\ell \notin \{i,\dots, j\},\)</span> i.e., there would be  types</p>
<div class="math notranslate nohighlight">
\[
z_i &lt; z_k &lt; z_j &lt; z_\ell
\]</div>
<p>with matches <span class="math notranslate nohighlight">\((z_i,z_j)\)</span> and <span class="math notranslate nohighlight">\((z_k, z_\ell),\)</span> violating the no intersecting pairs property.</p>
<p>We conclude that we can define a binary relation on <span class="math notranslate nohighlight">\([N]\)</span> such that <span class="math notranslate nohighlight">\(i \sim j\)</span> if there is an equal number of agents of each side in <span class="math notranslate nohighlight">\(\{i,i+1,\dots, j\}\)</span> (or if this set is empty).</p>
<p>This is an equivalence relation, so we can find associated equivalence classes that we call <em>layers</em>.</p>
<p>By the reasoning above, in an optimal solution all pairs <span class="math notranslate nohighlight">\(i,j\)</span> (of opposite sides) which are matched belong to the same layer, hence we can solve the assignment problem associated to each layer and then add up the solutions.</p>
<p>In terms of distributions, <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j,\)</span> of types <span class="math notranslate nohighlight">\(x \in X\)</span> and <span class="math notranslate nohighlight">\(y \in Y\)</span> respectively, belong to the same layer (i.e., <span class="math notranslate nohighlight">\(x \sim y\)</span>) if and only if <span class="math notranslate nohighlight">\(F(y-) - F(x) = G(y-) - G(x).\)</span></p>
<p>If  <span class="math notranslate nohighlight">\(F\)</span> and <span class="math notranslate nohighlight">\(G\)</span> were continuous, then  <span class="math notranslate nohighlight">\(F(y) - F(x) = G(y) - G(x) \iff F(x) - G(x) = F(y) - G(y).\)</span></p>
<p>This suggests that the following quantity plays an important role:</p>
<div class="math notranslate nohighlight">
\[
H(z) := F(z) - G(z), \text{ for } z \in \mathbb{R}.
\]</div>
<p>Returning to our general (integer) discrete setting, let’s plot <span class="math notranslate nohighlight">\(H\)</span>.</p>
<p>Notice that <span class="math notranslate nohighlight">\(H\)</span> is right-continuous (being the difference of right-continuous functions) and that upward (resp. downward) jumps correspond to point masses of agents with types from <span class="math notranslate nohighlight">\(X\)</span> (resp. <span class="math notranslate nohighlight">\(Y\)</span>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_H_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">range_x_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scatter</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="c1"># Determine H(z) = F(z) - G(z)</span>
    <span class="n">H_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_z</span><span class="p">)</span>
    
    <span class="c1"># Plot H(z)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># determine the step points for horizontal lines</span>
    <span class="n">step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="bp">self</span><span class="o">.</span><span class="n">support_z</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="mf">.05</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">support_z</span><span class="o">.</span><span class="n">ptp</span><span class="p">()],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">support_z</span><span class="p">,</span>
                           <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">support_z</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mf">.05</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">support_z</span><span class="o">.</span><span class="n">ptp</span><span class="p">()]))</span>
    <span class="n">height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">H_z</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    
    <span class="c1"># plot the horizontal lines of the step function</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">step</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">step</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">step</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
    
    <span class="c1"># draw dashed vertical lines for the step function</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">step</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">step</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">step</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="p">[</span><span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> 
                <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
    
    <span class="c1"># plot discontinuities points of H(z)</span>
    <span class="k">if</span> <span class="n">scatter</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">),</span> <span class="n">H_z</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">q_z</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">),</span> <span class="n">H_z</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">q_z</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">range_x_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">range_x_axis</span><span class="p">)</span>

    <span class="c1"># Add labels and title</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Underqualification Measure (Off-Diagonal)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;$z$&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;$H(z)$&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">OffDiagonal</span><span class="o">.</span><span class="n">plot_H_z</span> <span class="o">=</span> <span class="n">plot_H_z</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">example_off_diag</span><span class="o">.</span><span class="n">plot_H_z</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/f2bbf44a7b907b7c6be536f7047734e7a2e8da6cbd2f2b21fd25367c283e583d.png" src="_images/f2bbf44a7b907b7c6be536f7047734e7a2e8da6cbd2f2b21fd25367c283e583d.png" />
</div>
</div>
<p>The layering property extends to the general discrete setting.</p>
<p>There are <span class="math notranslate nohighlight">\(|H(\mathbb{R})|-1\)</span> layers in total.</p>
<p>Enumerating the range of <span class="math notranslate nohighlight">\(H\)</span> as <span class="math notranslate nohighlight">\(H(\mathbb{R}) = \{h_1,h_2, \dots, h_{|H(\mathbb{R})|}\}\)</span> with <span class="math notranslate nohighlight">\(h_1 &lt; h_2 &lt; \dots &lt; h_{|H(\mathbb{R})|},\)</span> we can define layer <span class="math notranslate nohighlight">\(L_\ell,\)</span> for <span class="math notranslate nohighlight">\(\ell \in \{ 1,\dots,|H(\mathbb{R})|-1\}\)</span> as the collection of types <span class="math notranslate nohighlight">\(z \in Z\)</span> such that</p>
<div class="math notranslate nohighlight">
\[
H(z-) \leq h_{\ell -1} &lt; h_{\ell } \leq H(z),
\]</div>
<p>(which are types in <span class="math notranslate nohighlight">\(X\)</span>), or</p>
<div class="math notranslate nohighlight">
\[
H(z) \leq h_{\ell -1} &lt; h_{\ell } \leq H(z-),
\]</div>
<p>which are types in <span class="math notranslate nohighlight">\(Y\)</span>.</p>
<p>The <em>mass</em> associated with  layer <span class="math notranslate nohighlight">\(L_\ell\)</span> is <span class="math notranslate nohighlight">\(M_\ell = h_{\ell+1}- h_{\ell}.\)</span></p>
<p>Intuitively, a layer <span class="math notranslate nohighlight">\(L_\ell\)</span> consists of some mass <span class="math notranslate nohighlight">\(M_\ell,\)</span> of multiple types in <span class="math notranslate nohighlight">\(Z,\)</span> i.e. the problem within the layer is <em>unitary</em>.</p>
<p>A unitary problem is essentially an assignment problem up to a constant: we can solve the problem with unit mass and then rescale a solution by <span class="math notranslate nohighlight">\(M_\ell.\)</span></p>
<p>Moreover, each layer <span class="math notranslate nohighlight">\(L_\ell\)</span> contains an even number of types <span class="math notranslate nohighlight">\(N_\ell \in 2\mathbb{N},\)</span> which are alternating, i.e., ordering them as <span class="math notranslate nohighlight">\(z_1 &lt; z_2\dots &lt; z_{ N_\ell-1} &lt; z_{ N_\ell}\)</span> all odd (or even, respectively) indexed types belong to the same side.</p>
<p>The following method finds the layers associated with distributions <span class="math notranslate nohighlight">\(F\)</span> and <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>Again, types in <span class="math notranslate nohighlight">\(X\)</span> are indexed with <span class="math notranslate nohighlight">\(\{0, \dots,|X|-1\}\)</span> and types in <span class="math notranslate nohighlight">\(Y\)</span> with <span class="math notranslate nohighlight">\(\{|X|, \dots,|X| + |Y|-1\}\)</span>.</p>
<p>Using these indices (instead of the types themselves) to represent the layers allows  keeping  track of  sides  types in each layer, without adding an additional bit of information that would  identify the side of the first type in the layer, which, because  a layer is alternating,  would then allow identifying  sides of all  types in the layer.</p>
<p>In addition, using indices will let us  extract the cost function within a layer from the cost function <span class="math notranslate nohighlight">\(c_{zz'}\)</span> computed offline.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find_layers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Compute H(z) on the joint support</span>
    <span class="n">H_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_z</span><span class="p">)])</span>

    <span class="c1"># Compute the range of H, i.e. H(R), stored in ascending order</span>
    <span class="n">layers_height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">H_z</span><span class="p">)</span>
    
    <span class="c1"># Compute the mass of each layer</span>
    <span class="n">layers_mass</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">layers_height</span><span class="p">)</span>

    <span class="c1"># Compute layers</span>
    <span class="c1"># the following |H(R)|x|Z| matrix has entry (z,l) equal to 1 iff type z belongs to layer l</span>
    <span class="n">layers_01</span> <span class="o">=</span> <span class="p">((</span><span class="n">H_z</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">layers_height</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span> 
                 <span class="o">*</span> <span class="p">(</span><span class="n">layers_height</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">H_z</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span> <span class="o">|</span>
                <span class="p">(</span><span class="n">H_z</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">&lt;=</span> <span class="n">layers_height</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span> 
                 <span class="o">*</span> <span class="p">(</span><span class="n">layers_height</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">H_z</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    
    <span class="c1"># each layer is reshaped as a list of indices correponding to types</span>
    <span class="n">layers</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">type_z</span><span class="p">[</span><span class="n">layers_01</span><span class="p">[</span><span class="n">ell</span><span class="p">]]</span> 
                <span class="k">for</span> <span class="n">ell</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layers_height</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">layers</span><span class="p">,</span> <span class="n">layers_mass</span><span class="p">,</span> <span class="n">layers_height</span><span class="p">,</span> <span class="n">H_z</span>

<span class="n">OffDiagonal</span><span class="o">.</span><span class="n">find_layers</span> <span class="o">=</span> <span class="n">find_layers</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">layers_list_example</span><span class="p">,</span> <span class="n">layers_mass_example</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">example_off_diag</span><span class="o">.</span><span class="n">find_layers</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">layers_list_example</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[array([23, 10]), array([27,  3, 23, 10]), array([16,  2, 21,  3, 25,  8, 23, 12]), array([16,  2, 21,  3, 25, 12]), array([22,  0, 16,  2, 21,  3, 18, 12]), array([15,  0, 16,  2, 14,  5, 21,  3, 18,  9]), array([20,  0, 16,  2, 14,  5, 21,  3, 19, 11, 24,  1, 18,  9]), array([ 2, 26,  5, 21,  3, 19,  4, 18]), array([ 2, 26,  7, 21,  3, 19,  4, 17,  6, 18]), array([13, 26,  7, 21,  3, 19,  6, 18]), array([ 6, 18]), array([ 6, 28]), array([ 6, 29])]
</pre></div>
</div>
</div>
</div>
<p>The following method gives a graphical representation of the layers.</p>
<p>From the  picture it is easy to spot  two key features described  above:</p>
<ul class="simple">
<li><p>types are alternating</p></li>
<li><p>the layer problem is unitary</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_layers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">)):</span>
    <span class="c1"># Find layers</span>
    <span class="n">layers</span><span class="p">,</span> <span class="n">layers_mass</span> <span class="p">,</span> <span class="n">layers_height</span><span class="p">,</span> <span class="n">H_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_layers</span><span class="p">()</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>

    <span class="c1"># Plot H(z)</span>
    <span class="n">step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="bp">self</span><span class="o">.</span><span class="n">support_z</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="mf">.05</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">support_z</span><span class="o">.</span><span class="n">ptp</span><span class="p">()],</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">support_z</span><span class="p">,</span>
                           <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">support_z</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mf">.05</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">support_z</span><span class="o">.</span><span class="n">ptp</span><span class="p">()]))</span>
    <span class="n">height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">H_z</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s1">&#39;post&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;CDF&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Plot layers</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">viridis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">layers</span><span class="p">)))</span> 
    <span class="k">for</span>  <span class="n">ell</span><span class="p">,</span> <span class="n">layer</span>  <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">types_list</span><span class="p">[</span><span class="n">layer</span><span class="p">],</span> <span class="n">layers_height</span><span class="p">[</span><span class="n">ell</span><span class="p">]</span> <span class="p">,</span> 
                   <span class="n">layers_height</span><span class="p">[</span><span class="n">ell</span><span class="p">]</span> <span class="o">+</span> <span class="n">layers_mass</span><span class="p">[</span><span class="n">ell</span><span class="p">],</span> 
                   <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">ell</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">types_list</span><span class="p">[</span><span class="n">layer</span><span class="p">],</span> 
                    <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">))</span> <span class="o">*</span> <span class="n">layers_height</span><span class="p">[</span><span class="n">ell</span><span class="p">]</span> 
                    <span class="o">+</span><span class="mf">.5</span> <span class="o">*</span> <span class="n">layers_mass</span><span class="p">[</span><span class="n">ell</span><span class="p">],</span> 
                    <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">ell</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">layers_height</span><span class="p">[</span><span class="n">ell</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">ell</span><span class="p">],</span> 
                    <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Add labels and title</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;$z$&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Layers&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">OffDiagonal</span><span class="o">.</span><span class="n">plot_layers</span> <span class="o">=</span> <span class="n">plot_layers</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">example_off_diag</span><span class="o">.</span><span class="n">plot_layers</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/3e8d34383549c2f97c034bccd5623269621d8249fbeafeee96a1216ddbed93ad.png" src="_images/3e8d34383549c2f97c034bccd5623269621d8249fbeafeee96a1216ddbed93ad.png" />
</div>
</div>
</section>
<section id="solving-a-layer">
<h3><span class="section-number">16.3.2. </span>Solving a layer<a class="headerlink" href="#solving-a-layer" title="Permalink to this heading">#</a></h3>
<p>Recall that layer <span class="math notranslate nohighlight">\(L_\ell\)</span> consists of a list of distinct types from <span class="math notranslate nohighlight">\(Y \sqcup X\)</span></p>
<div class="math notranslate nohighlight">
\[
z_1 &lt; z_2\dots &lt; z_{N_\ell-1} &lt; z_{N_\ell}, 
\]</div>
<p>which is alternating.</p>
<p>The problem within a layer is unitary.</p>
<p>Hence we can solve the problem with unit masses and later rescale the solution by the layer’s mass <span class="math notranslate nohighlight">\(M_\ell\)</span>.</p>
<p>Let us select a layer from the example above (we pick the one with maximum number of types) and plot the types on the real line</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Pick layer with maximum number of types</span>
<span class="n">layer_id_example</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">layers_list_example</span><span class="p">),</span> 
                    <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">layer_example</span> <span class="o">=</span> <span class="n">layers_list_example</span><span class="p">[</span><span class="n">layer_id_example</span><span class="p">]</span>


<span class="c1"># Plot layer types</span>
<span class="k">def</span> <span class="nf">plot_layer_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">3</span><span class="p">)):</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
    
    <span class="c1"># Scatter plot n_x</span>
    <span class="n">x_layer</span> <span class="o">=</span> <span class="n">layer</span><span class="p">[</span><span class="n">layer</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">)]</span>
    <span class="n">y_layer</span> <span class="o">=</span> <span class="n">layer</span><span class="p">[</span><span class="n">layer</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">)]</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">)</span>
    <span class="n">M_ell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_layer</span><span class="p">))</span><span class="o">*</span> <span class="n">mass</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">[</span><span class="n">x_layer</span><span class="p">],</span> <span class="n">M_ell</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;X types&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">[</span><span class="n">x_layer</span><span class="p">],</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span> <span class="n">M_ell</span><span class="p">,</span> 
               <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">)</span>
    
    <span class="c1"># Scatter plot m_y</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">[</span><span class="n">y_layer</span><span class="p">],</span> <span class="o">-</span> <span class="n">M_ell</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Y types&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">[</span><span class="n">y_layer</span><span class="p">],</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=-</span> <span class="n">M_ell</span><span class="p">,</span>
               <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">)</span>

    <span class="c1"># Add grid and y=0 axis</span>
    <span class="c1"># plt.grid(True)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">((</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c1"># Labeling the axes and the title</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;mass&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Distributions of types in the layer&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
<span class="n">ConcaveCostOT</span><span class="o">.</span><span class="n">plot_layer_types</span> <span class="o">=</span> <span class="n">plot_layer_types</span>

<span class="n">example_off_diag</span><span class="o">.</span><span class="n">plot_layer_types</span><span class="p">(</span><span class="n">layer_example</span><span class="p">,</span> 
                                <span class="n">layers_mass_example</span><span class="p">[</span><span class="n">layer_id_example</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/0f676e54e4d0d75bcd0e0e29d618f48247cad56b6018b4f9c454d618070aa1a8.png" src="_images/0f676e54e4d0d75bcd0e0e29d618f48247cad56b6018b4f9c454d618070aa1a8.png" />
</div>
</div>
<p>Given the structure of a layer and the <em>no intersecting pairs</em> property, the optimal matching and value of the layer can be found recursively.</p>
<p>Indeed, if in certain optimal matching <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(j \in [N_\ell],\)</span> <span class="math notranslate nohighlight">\( j-1 \)</span> odd, are paired, then there is no matching between agents in <span class="math notranslate nohighlight">\([2,j-1]\)</span> and those in <span class="math notranslate nohighlight">\([j+1,N_\ell]\)</span> (if both are non empty, i.e., <span class="math notranslate nohighlight">\(j\)</span> is not <span class="math notranslate nohighlight">\(2\)</span> or <span class="math notranslate nohighlight">\(N_\ell\)</span>).</p>
<p>Hence  in such optimal solution agents in <span class="math notranslate nohighlight">\([2,j-1]\)</span> are matched among themselves.</p>
<p>Since <span class="math notranslate nohighlight">\([z_2,z_{j-1}]\)</span> (as well as <span class="math notranslate nohighlight">\([z_{j+1},z_{N_\ell}]\)</span>) is alternating, we can reason recursively.</p>
<p>Let <span class="math notranslate nohighlight">\(V_{ij}\)</span> be the optimal value of matching agents in <span class="math notranslate nohighlight">\([i,j]\)</span> with  <span class="math notranslate nohighlight">\(i,j \in [N_\ell],\)</span> <span class="math notranslate nohighlight">\(j -i \in \{1,3,\dots,N_\ell-1\}\)</span>.</p>
<p>Suppose that we computed the value <span class="math notranslate nohighlight">\(V_{ij}\)</span> for all <span class="math notranslate nohighlight">\(i,j \in [N_\ell]\)</span> with <span class="math notranslate nohighlight">\(i-j \in \{1,3,\dots,t-2\}\)</span> for some odd natural number <span class="math notranslate nohighlight">\(t\)</span>.</p>
<p>Then, for <span class="math notranslate nohighlight">\(i,j \in [N_\ell]\)</span> with <span class="math notranslate nohighlight">\(i-j= t\)</span> we have</p>
<div class="math notranslate nohighlight">
\[
V_{ij} = \min_{k \in \{i+1,i+3,\dots,j\}} \left\{ c_{ik} + V_{i+1,k-1} + V_{k+1,j}\right\}
\]</div>
<p>with the RHS depending only on previously computed values.</p>
<p>We set the boundary conditions at <span class="math notranslate nohighlight">\(t=-1\)</span>: <span class="math notranslate nohighlight">\(V_{i+1,i} = 0\)</span> for each <span class="math notranslate nohighlight">\(i \in [N_\ell],\)</span> so that we can apply the same Bellman equation at <span class="math notranslate nohighlight">\(t =1.\)</span></p>
<p>The following method takes as input the layer types indices and computes the value function as a matrix <span class="math notranslate nohighlight">\([V_{ij}]_{ i \in [N_\ell+1], j \in [N_\ell ]}\)</span>.</p>
<p>In order to  distinguish  entries that  are relevant for our computations from those that  are never accessed, we initialize this matrix as full of  NaN values.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">solve_bellman_eqs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">layer</span><span class="p">):</span>
    <span class="c1"># Recover cost function within the layer</span>
    <span class="n">cost_i_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_z_z</span><span class="p">[</span><span class="n">layer</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">layer</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]]</span>

    <span class="c1"># Initialize value function</span>
    <span class="n">V_i_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="c1"># Add boundary conditions</span>
    <span class="n">i_bdry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">))</span>
    <span class="n">V_i_j</span><span class="p">[</span><span class="n">i_bdry</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">i_bdry</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">):</span>
        <span class="c1"># Select agents i in [n_L-t] (with potential partners j&#39;s in [t,n_L])</span>
        <span class="n">i_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span><span class="o">-</span><span class="n">t</span><span class="p">)</span>

        <span class="c1"># For each i, select each k with |k-i| &lt;= t </span>
        <span class="c1"># (potential partners of i within segment)</span>
        <span class="n">index_ik</span> <span class="o">=</span>  <span class="n">i_t</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)[</span><span class="kc">None</span><span class="p">,:]</span>

        <span class="c1"># Compute optimal value for pairs with |i-j| = t </span>
        <span class="n">V_i_j</span><span class="p">[</span><span class="n">i_t</span><span class="p">,</span> <span class="n">i_t</span> <span class="o">+</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">cost_i_j</span><span class="p">[</span><span class="n">i_t</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">index_ik</span><span class="p">]</span> <span class="o">+</span> 
                                <span class="n">V_i_j</span><span class="p">[</span><span class="n">i_t</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">index_ik</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> 
                                <span class="n">V_i_j</span><span class="p">[</span><span class="n">index_ik</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i_t</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">t</span><span class="p">])</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Go to next odd integer</span>
        <span class="n">t</span> <span class="o">+=</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="n">V_i_j</span>

<span class="n">OffDiagonal</span><span class="o">.</span><span class="n">solve_bellman_eqs</span> <span class="o">=</span> <span class="n">solve_bellman_eqs</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s compute values for the layer from our example.</p>
<p>Only non-NaN entries are actually used in the computations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute layer value function</span>
<span class="n">V_i_j</span> <span class="o">=</span> <span class="n">example_off_diag</span><span class="o">.</span><span class="n">solve_bellman_eqs</span><span class="p">(</span><span class="n">layer_example</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Type indices in the layer: </span><span class="si">{</span><span class="n">layer_example</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;##########################&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Section of the Value function of the layer:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">V_i_j</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)[:</span><span class="nb">min</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">V_i_j</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> 
                         <span class="p">:</span><span class="nb">min</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">V_i_j</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Type indices in the layer: [20  0 16  2 14  5 21  3 19 11 24  1 18  9]
##########################
Section of the Value function of the layer:
[[  nan  4.29   nan  5.73   nan  9.82   nan 13.9    nan 14.52]
 [ 0.     nan  2.75   nan  6.17   nan  8.44   nan 10.56   nan]
 [  nan  0.     nan  1.44   nan  5.52   nan  9.6    nan 10.22]
 [  nan   nan  0.     nan  3.58   nan  5.84   nan  7.96   nan]
 [  nan   nan   nan  0.     nan  4.08   nan  8.16   nan  8.78]
 [  nan   nan   nan   nan  0.     nan  2.26   nan  4.38   nan]
 [  nan   nan   nan   nan   nan  0.     nan  4.08   nan  4.7 ]
 [  nan   nan   nan   nan   nan   nan  0.     nan  2.12   nan]
 [  nan   nan   nan   nan   nan   nan   nan  0.     nan  0.62]
 [  nan   nan   nan   nan   nan   nan   nan   nan  0.     nan]]
</pre></div>
</div>
</div>
</div>
<p>Having computed the value function, we can proceed to compute the optimal matching as the <em>policy</em> that attains the value function that solves the  Bellman equation (<em>policy evaluation</em>).</p>
<p>We start from agent <span class="math notranslate nohighlight">\(1\)</span> and match it with the <span class="math notranslate nohighlight">\(k\)</span> that achieves the minimum in the equation associated with <span class="math notranslate nohighlight">\(V_{1,2N_\ell}.\)</span></p>
<p>Then we store  segments <span class="math notranslate nohighlight">\([2,k-1]\)</span> and <span class="math notranslate nohighlight">\([k+1,2N_\ell]\)</span> (if not empty).</p>
<p>In general, given a segment <span class="math notranslate nohighlight">\([i,j],\)</span> we match <span class="math notranslate nohighlight">\(i\)</span> with <span class="math notranslate nohighlight">\(k\)</span> that achieves the minimum in the equation associated with  <span class="math notranslate nohighlight">\(V_{ij}\)</span> and store the segments <span class="math notranslate nohighlight">\([i,k-1]\)</span> and <span class="math notranslate nohighlight">\([k+1,j]\)</span> (if not empty).</p>
<p>The algorithm proceeds until there are no segments left.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find_layer_matching</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">V_i_j</span><span class="p">,</span> <span class="n">layer</span><span class="p">):</span>
    <span class="c1"># Initialize</span>
    <span class="n">segments_to_process</span>  <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">))]</span>
    <span class="n">matching</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">)),</span> <span class="nb">bool</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">segments_to_process</span><span class="p">:</span>
        <span class="c1"># Pick i, first agent of the segment </span>
        <span class="c1"># and potential partners i+1,i+3,..., in the segment</span>
        <span class="n">segment</span> <span class="o">=</span> <span class="n">segments_to_process</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">i_0</span> <span class="o">=</span> <span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">potential_matches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i_0</span><span class="p">,</span> <span class="n">segment</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Compute optimal partner j_i </span>
        <span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cost_z_z</span><span class="p">[</span><span class="n">layer</span><span class="p">[</span><span class="n">i_0</span><span class="p">],</span><span class="n">layer</span><span class="p">[</span><span class="n">potential_matches</span><span class="p">]]</span> <span class="o">+</span> 
                <span class="n">V_i_j</span><span class="p">[</span><span class="n">i_0</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">potential_matches</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                <span class="n">V_i_j</span><span class="p">[</span><span class="n">potential_matches</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">segment</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        
        <span class="n">j_i_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">i_0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
     
        <span class="c1"># Add matched pair (i,j_i)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_pair_to_matching</span><span class="p">(</span><span class="n">layer</span><span class="p">[[</span><span class="n">i_0</span><span class="p">,</span><span class="n">j_i_0</span><span class="p">]],</span> <span class="n">matching</span><span class="p">)</span>

        <span class="c1"># Update segments to process: </span>
        <span class="c1"># remove current segment</span>
        <span class="n">segments_to_process</span> <span class="o">=</span> <span class="n">segments_to_process</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        
        <span class="c1"># add [i+1,j-1] and [j+1,last agent of the segment]</span>
        <span class="k">if</span> <span class="n">j_i_0</span> <span class="o">&gt;</span> <span class="n">i_0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">segments_to_process</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i_0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j_i_0</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">j_i_0</span> <span class="o">&lt;</span> <span class="n">segment</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">segments_to_process</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">j_i_0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">segment</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">matching</span> 

<span class="n">OffDiagonal</span><span class="o">.</span><span class="n">find_layer_matching</span> <span class="o">=</span> <span class="n">find_layer_matching</span>
</pre></div>
</div>
</div>
</div>
<p>Lets apply this method our example to find the matching within the layer and then rescale it by <span class="math notranslate nohighlight">\(M_\ell\)</span>.</p>
<p>Note that the unscaled value equals <span class="math notranslate nohighlight">\(V_{1,N_\ell}.\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">matching_layer</span> <span class="o">=</span> <span class="n">example_off_diag</span><span class="o">.</span><span class="n">find_layer_matching</span><span class="p">(</span><span class="n">V_i_j</span><span class="p">,</span><span class="n">layer_example</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Value of the layer (unscaled): </span><span class="si">{</span><span class="p">(</span><span class="n">matching_layer</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">example_off_diag</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Value of the layer (scaled by the mass = </span><span class="si">{</span><span class="n">layers_mass_example</span><span class="p">[</span><span class="n">layer_id_example</span><span class="p">]</span><span class="si">}</span><span class="s2">): &quot;</span>
     <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">layers_mass_example</span><span class="p">[</span><span class="n">layer_id_example</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">matching_layer</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">example_off_diag</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Value of the layer (unscaled): 24.764959193288938
Value of the layer (scaled by the mass = 1): 24.764959193288938
</pre></div>
</div>
</div>
</div>
<p>The following method plots the matching within a layer.</p>
<p>We apply it to the layer from our example.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_layer_matching</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">matching_layer</span><span class="p">):</span>
    <span class="c1"># Create the figure and axis</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>

    <span class="c1"># Plot the points on the x-axis</span>
    <span class="n">X_types_layer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">[</span><span class="n">layer</span><span class="p">[</span><span class="n">layer</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">)]]</span>
    <span class="n">Y_types_layer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">[</span><span class="n">layer</span><span class="p">[</span><span class="n">layer</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">)]</span> 
                    <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">)]</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X_types_layer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">X_types_layer</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> 
                <span class="n">s</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">Y_types_layer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Y_types_layer</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> 
                <span class="n">s</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

    <span class="c1"># Draw semicircles for each row in matchings</span>
    <span class="n">matched_types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">matching_layer</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">matched_types_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">[</span><span class="n">matched_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">matched_types_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">[</span><span class="n">matched_types</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matched_types_x</span><span class="p">)):</span>
        <span class="n">width</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">matched_types_x</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">-</span> <span class="n">matched_types_y</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
        <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">matched_types_x</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">+</span> <span class="n">matched_types_y</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>        
        <span class="n">height</span> <span class="o">=</span> <span class="n">width</span> 
        <span class="n">semicircle</span> <span class="o">=</span> <span class="n">patches</span><span class="o">.</span><span class="n">Arc</span><span class="p">((</span><span class="n">center</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">theta1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
                    <span class="n">theta2</span><span class="o">=</span><span class="mi">180</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">semicircle</span><span class="p">)</span>

    <span class="c1"># Add title and layout settings</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Optimal Layer Matching&#39;</span> <span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">((</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span> 
    <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span> 
    <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>  
    <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">support_z</span><span class="o">.</span><span class="n">ptp</span><span class="p">()</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">ConcaveCostOT</span><span class="o">.</span><span class="n">plot_layer_matching</span> <span class="o">=</span> <span class="n">plot_layer_matching</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">example_off_diag</span><span class="o">.</span><span class="n">plot_layer_matching</span><span class="p">(</span><span class="n">layer_example</span><span class="p">,</span> <span class="n">matching_layer</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/d6b976828288c53dd860c8414bbd52e1b7542ab840aa9bcee38714f7649d3922.png" src="_images/d6b976828288c53dd860c8414bbd52e1b7542ab840aa9bcee38714f7649d3922.png" />
</div>
</div>
<section id="solving-a-layer-in-a-smarter-way">
<h4><span class="section-number">16.3.2.1. </span>Solving a layer in a smarter way<a class="headerlink" href="#solving-a-layer-in-a-smarter-way" title="Permalink to this heading">#</a></h4>
<p>We  now present two key results in the context of OT with concave type costs.</p>
<p>We refer <span id="id6">[<a class="reference internal" href="zreferences.html#id3" title="Job Boerma, Aleh Tsyvinski, Ruodu Wang, and Zhenyuan Zhang. Composite sorting. Technical Report, University of Wisconsin, 2024.">Boerma <em>et al.</em>, 2024</a>]</span> and <span id="id7">[<a class="reference internal" href="zreferences.html#id4" title="Julie Delon, Julien Salomon, and Andrei Sobolevski. Minimum-weight perfect matching for non-intrinsic distances on the line. arXiv preprint arXiv:1102.1558, 2011.">Delon <em>et al.</em>, 2011</a>]</span> for proofs.</p>
<p>Consider the problem faced within a layer, i.e., types from <span class="math notranslate nohighlight">\(Y \sqcup X\)</span></p>
<div class="math notranslate nohighlight">
\[ 
z_1 &lt; z_2\dots &lt; z_{N_\ell-1} &lt; z_{N_\ell}, \quad N_\ell \in 2 \mathbb{N}
\]</div>
<p>are alternating and the problem is unitary.</p>
<p>Given a matching on <span class="math notranslate nohighlight">\([1,k],\)</span> <span class="math notranslate nohighlight">\(k \in [N_\ell],\)</span> <span class="math notranslate nohighlight">\(k\)</span> even, we say that a matched pair <span class="math notranslate nohighlight">\((i,j)\)</span> within this matching is <em>hidden</em> if there is a matched pair <span class="math notranslate nohighlight">\((i',j')\)</span> with <span class="math notranslate nohighlight">\(i' &lt; i &lt;j &lt;j'.\)</span></p>
<p>Visually, the arc joining <span class="math notranslate nohighlight">\((i',j')\)</span> surmounts the arc joining <span class="math notranslate nohighlight">\((i,j).\)</span></p>
<p><strong>Theorem (DSS)</strong> Given an optimal matching on <span class="math notranslate nohighlight">\([1,k],\)</span> if <span class="math notranslate nohighlight">\((i,j)\)</span> is hidden in this matching, then the pair <span class="math notranslate nohighlight">\((i,j)\)</span> belongs to every optimal matching on <span class="math notranslate nohighlight">\([1, 2 N_\ell]\)</span> and is hidden in this matching too.</p>
<p>As a consequence, there exists a more efficient way to compute the value function within a layer.</p>
<p>It can be shown that the solving the following second-order difference  equations delivers the same result as the Bellman equations above:</p>
<div class="math notranslate nohighlight">
\[ 
V_{ij} = \min \{ c_{ij} + V_{i+1,j-1}, V_{i+2,j} + V_{i,j-2} - V_{i+2,j-2}\}
\]</div>
<p>for <span class="math notranslate nohighlight">\(i,j \in [N_\ell],\)</span> <span class="math notranslate nohighlight">\(j-i\)</span> odd, with boundary conditions <span class="math notranslate nohighlight">\(V_{i+1,i}= 0\)</span> for <span class="math notranslate nohighlight">\(i \in [0,N_\ell ]\)</span> and <span class="math notranslate nohighlight">\(V_{i+2, i-1} = - c_{i,i+1}\)</span> for <span class="math notranslate nohighlight">\(i \in [N_\ell -1]\)</span> .</p>
<p>The following method uses these equations to compute the value function that  is stored as a matrix <span class="math notranslate nohighlight">\([V_{ij}]_{ i \in [N_\ell+1], j \in [N_\ell +1]}.\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">solve_bellman_eqs_DSS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">layer</span><span class="p">):</span>
    <span class="c1"># Recover cost function within the layer</span>
    <span class="n">cost_i_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_z_z</span><span class="p">[</span><span class="n">layer</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">layer</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]]</span>

    <span class="c1"># Initialize value function</span>
    <span class="n">V_i_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    
    <span class="c1"># Add boundary conditions</span>
    <span class="n">V_i_j</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i_bdry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">V_i_j</span><span class="p">[</span><span class="n">i_bdry</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">i_bdry</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">cost_i_j</span><span class="p">[</span><span class="n">i_bdry</span><span class="p">,</span> <span class="n">i_bdry</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">):</span>
        <span class="c1"># Select agents i in [n_l-t] and potential partner j=i+t for each i</span>
        <span class="n">i_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span><span class="o">-</span><span class="n">t</span><span class="p">)</span>
        <span class="n">j_t</span> <span class="o">=</span> <span class="n">i_t</span> <span class="o">+</span> <span class="n">t</span> <span class="o">+</span><span class="mi">1</span>       

        <span class="c1"># Compute optimal values for ij with j-i = t </span>
        <span class="n">V_i_j</span><span class="p">[</span><span class="n">i_t</span><span class="p">,</span> <span class="n">j_t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">cost_i_j</span><span class="p">[</span><span class="n">i_t</span><span class="p">,</span> <span class="n">j_t</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
                        <span class="o">+</span> <span class="n">V_i_j</span><span class="p">[</span><span class="n">i_t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j_t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="n">V_i_j</span><span class="p">[</span><span class="n">i_t</span><span class="p">,</span> <span class="n">j_t</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">V_i_j</span><span class="p">[</span><span class="n">i_t</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j_t</span><span class="p">]</span> 
                        <span class="o">-</span> <span class="n">V_i_j</span><span class="p">[</span><span class="n">i_t</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j_t</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span>
        
        <span class="c1">## Go to next odd integer</span>
        <span class="n">t</span> <span class="o">+=</span> <span class="mi">2</span>
    
    <span class="k">return</span> <span class="n">V_i_j</span>

<span class="n">OffDiagonal</span><span class="o">.</span><span class="n">solve_bellman_eqs_DSS</span> <span class="o">=</span> <span class="n">solve_bellman_eqs_DSS</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s apply the algorithm to our example and compare outcomes with those attained  with the Bellman equations above.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">V_i_j_DSS</span> <span class="o">=</span> <span class="n">example_off_diag</span><span class="o">.</span><span class="n">solve_bellman_eqs_DSS</span><span class="p">(</span><span class="n">layer_example</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Type indices of the layer: </span><span class="si">{</span><span class="n">layer_example</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;##########################&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Section of Value function of the layer:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">V_i_j_DSS</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)[:</span><span class="nb">min</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">V_i_j_DSS</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> 
                         <span class="p">:</span><span class="nb">min</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">V_i_j_DSS</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;##########################&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Difference with previous Bellman equations: </span><span class="se">\</span>
<span class="s2">      </span><span class="si">{</span><span class="p">(</span><span class="n">V_i_j_DSS</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">V_i_j</span><span class="p">)[</span><span class="n">V_i_j</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Type indices of the layer: [20  0 16  2 14  5 21  3 19 11 24  1 18  9]
##########################
Section of Value function of the layer:
[[ 0.     nan  4.29   nan  5.73   nan  9.82   nan 13.9    nan]
 [  nan  0.     nan  2.75   nan  6.17   nan  8.44   nan 10.56]
 [-4.29   nan  0.     nan  1.44   nan  5.52   nan  9.6    nan]
 [  nan -2.75   nan  0.     nan  3.58   nan  5.84   nan  7.96]
 [  nan   nan -1.44   nan  0.     nan  4.08   nan  8.16   nan]
 [  nan   nan   nan -3.58   nan  0.     nan  2.26   nan  4.38]
 [  nan   nan   nan   nan -4.08   nan  0.     nan  4.08   nan]
 [  nan   nan   nan   nan   nan -2.26   nan  0.     nan  2.12]
 [  nan   nan   nan   nan   nan   nan -4.08   nan  0.     nan]
 [  nan   nan   nan   nan   nan   nan   nan -2.12   nan  0.  ]]
##########################
Difference with previous Bellman equations:       4.440892098500626e-14
</pre></div>
</div>
</div>
</div>
<p>We can actually compute the optimal matching within the layer simultaneously with computing the value function, rather than sequentially.</p>
<p>The key idea is that, if at some step of the computation of the values the left branch of the minimum above achieves the minimum, say <span class="math notranslate nohighlight">\(V_{ij}= c_{ij} + V_{i+1,j-1},\)</span> then <span class="math notranslate nohighlight">\((i,j)\)</span> are optimally matched on <span class="math notranslate nohighlight">\([i,j]\)</span> and by the theorem above we get that a matching on <span class="math notranslate nohighlight">\([i+1,j-1]\)</span> which achieves <span class="math notranslate nohighlight">\( V_{i+1,j-1}\)</span> belongs to an optimal matching on the whole layer (since it is covered by the arc <span class="math notranslate nohighlight">\((i,j)\)</span> in <span class="math notranslate nohighlight">\([i,j]\)</span>).</p>
<p>We can therefore proceed as follows</p>
<p>We initialize an empty matching and a list with all the agents in the layer (representing the agents which are not matched yet).</p>
<p>Then whenever the left branch of the minimum is achieved for some <span class="math notranslate nohighlight">\((i,j)\)</span> in the computation of <span class="math notranslate nohighlight">\(V,\)</span> we take the collections of agents <span class="math notranslate nohighlight">\(k_1,\dots,k_M\)</span> in <span class="math notranslate nohighlight">\([i+1,j-1]\)</span> (in ascending order, i.e. with <span class="math notranslate nohighlight">\(z_{k_{p}} &lt; z_{k_{p+1}}\)</span>) that are not matched yet (if any) and add to the matching the pairs <span class="math notranslate nohighlight">\((k_1,k_2), (k_3,k_4),\dots,(k_{M-1},k_M).\)</span></p>
<p>Thus, we match each unmatched agent <span class="math notranslate nohighlight">\(k_p\)</span> in <span class="math notranslate nohighlight">\([i+1,j-1]\)</span> with the closest unmatched right neighbour <span class="math notranslate nohighlight">\(k_{p+1}\)</span> (starting from <span class="math notranslate nohighlight">\(k_1\)</span>).</p>
<p>Intuitively, if <span class="math notranslate nohighlight">\(k_p\)</span> were optimally matched with some <span class="math notranslate nohighlight">\(k_{q}\)</span> in <span class="math notranslate nohighlight">\([i+1,j-1]\)</span> and not with <span class="math notranslate nohighlight">\(k_{p+1}\)</span>, then <span class="math notranslate nohighlight">\(k_{p+1}\)</span> would have already been hidden by the match <span class="math notranslate nohighlight">\((k_p,k_{q})\)</span> from some previous computation (because <span class="math notranslate nohighlight">\(|k_p - k_q|&lt; |i-j|\)</span>) and it would therefore be matched.</p>
<p>Finally, if the process above leaves some umatched agents, we proceed by matching each of these agent with the closest unmatched right neighbour, starting again from the leftmost of these collection.</p>
<p>To gain understanding, note that this situation happens  when the left branch is achieved only for pairs <span class="math notranslate nohighlight">\(i,j\)</span> with <span class="math notranslate nohighlight">\(|i-j|=1,\)</span> which leads to the optimal matching <span class="math notranslate nohighlight">\((1,2), (2,3), \dots, (n_\ell -1, n_\ell).\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find_layer_matching_DSS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">layer</span><span class="p">):</span>
    <span class="c1"># Recover cost function within the layer</span>
    <span class="n">cost_i_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_z_z</span><span class="p">[</span><span class="n">layer</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">layer</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]]</span>
    
    <span class="c1"># Add boundary conditions</span>
    <span class="n">V_i_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">i_bdry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">V_i_j</span><span class="p">[</span><span class="n">i_bdry</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">i_bdry</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">cost_i_j</span><span class="p">[</span><span class="n">i_bdry</span><span class="p">,</span> <span class="n">i_bdry</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Initialize matching and list of to-match agents</span>
    <span class="n">unmatched</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">)</span>
    <span class="n">matching</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">)),</span> <span class="nb">bool</span><span class="p">)</span>

    <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">):</span>
        <span class="c1"># Compute optimal value for pairs with |i-j| = t </span>
        <span class="n">i_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span><span class="o">-</span><span class="n">t</span><span class="p">)</span>
        <span class="n">j_t</span> <span class="o">=</span> <span class="n">i_t</span> <span class="o">+</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="n">left_branch</span> <span class="o">=</span> <span class="n">cost_i_j</span><span class="p">[</span><span class="n">i_t</span><span class="p">,</span> <span class="n">j_t</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">V_i_j</span><span class="p">[</span><span class="n">i_t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j_t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">V_i_j</span><span class="p">[</span><span class="n">i_t</span><span class="p">,</span> <span class="n">j_t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">left_branch</span><span class="p">,</span> <span class="n">V_i_j</span><span class="p">[</span><span class="n">i_t</span><span class="p">,</span> <span class="n">j_t</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> 
                        <span class="o">+</span> <span class="n">V_i_j</span><span class="p">[</span><span class="n">i_t</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j_t</span><span class="p">]</span> <span class="o">-</span> <span class="n">V_i_j</span><span class="p">[</span><span class="n">i_t</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j_t</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span>
        
        <span class="c1"># Select each i for which left branch achieves minimum in the V_{i,i+t}</span>
        <span class="n">left_branch_achieved</span> <span class="o">=</span> <span class="n">i_t</span><span class="p">[</span><span class="n">left_branch</span> <span class="o">==</span> <span class="n">V_i_j</span><span class="p">[</span><span class="n">i_t</span><span class="p">,</span> <span class="n">j_t</span><span class="p">]]</span>
        
        <span class="c1"># Update matching</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">left_branch_achieved</span><span class="p">:</span>
            <span class="c1"># for each agent k in [i+1,i+t-1]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="n">t</span><span class="p">)[</span><span class="n">unmatched</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="n">t</span><span class="p">)]]:</span>   
                <span class="c1"># if k is unmatched</span>
                <span class="k">if</span> <span class="n">unmatched</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>                               
                    <span class="c1"># find unmatched right neighbour  </span>
                    <span class="n">j_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">))[</span><span class="n">unmatched</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:]][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># add pair to matching</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_pair_to_matching</span><span class="p">(</span><span class="n">layer</span><span class="p">[[</span><span class="n">k</span><span class="p">,</span> <span class="n">j_k</span><span class="p">]],</span> <span class="n">matching</span><span class="p">)</span> 
                    <span class="c1"># remove pair from unmatched agents list</span>
                    <span class="n">unmatched</span><span class="p">[[</span><span class="n">k</span><span class="p">,</span> <span class="n">j_k</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>                         
                    
        <span class="c1"># go to next odd integer</span>
        <span class="n">t</span> <span class="o">+=</span> <span class="mi">2</span>
    
    <span class="c1"># Each umatched agent is matched with next unmatched agent</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">))[</span><span class="n">unmatched</span><span class="p">]:</span>                  
        <span class="c1"># if i is unmatched</span>
        <span class="k">if</span> <span class="n">unmatched</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>                                 
            <span class="c1"># find unmatched right neighbour</span>
            <span class="n">j_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">))[</span><span class="n">unmatched</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]][</span><span class="mi">0</span><span class="p">]</span>  
            <span class="c1"># add pair to matching</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_pair_to_matching</span><span class="p">(</span><span class="n">layer</span><span class="p">[[</span><span class="n">i</span><span class="p">,</span> <span class="n">j_i</span><span class="p">]],</span> <span class="n">matching</span><span class="p">)</span> 
            <span class="c1"># remove pair from unmatched agents list </span>
            <span class="n">unmatched</span><span class="p">[[</span><span class="n">i</span><span class="p">,</span> <span class="n">j_i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>                          

    <span class="k">return</span> <span class="n">matching</span>

<span class="n">OffDiagonal</span><span class="o">.</span><span class="n">find_layer_matching_DSS</span> <span class="o">=</span> <span class="n">find_layer_matching_DSS</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">matching_layer_DSS</span> <span class="o">=</span> <span class="n">example_off_diag</span><span class="o">.</span><span class="n">find_layer_matching_DSS</span><span class="p">(</span><span class="n">layer_example</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; Value of layer with DSS recursive equations </span><span class="se">\</span>
<span class="si">{</span><span class="p">(</span><span class="n">matching_layer_DSS</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">example_off_diag</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; Value of layer with Bellman equations </span><span class="se">\</span>
<span class="si">{</span><span class="p">(</span><span class="n">matching_layer</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">example_off_diag</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> Value of layer with DSS recursive equations 24.764959193288938
 Value of layer with Bellman equations 24.764959193288938
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">example_off_diag</span><span class="o">.</span><span class="n">plot_layer_matching</span><span class="p">(</span><span class="n">layer_example</span><span class="p">,</span> <span class="n">matching_layer_DSS</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/d6b976828288c53dd860c8414bbd52e1b7542ab840aa9bcee38714f7649d3922.png" src="_images/d6b976828288c53dd860c8414bbd52e1b7542ab840aa9bcee38714f7649d3922.png" />
</div>
</div>
</section>
</section>
</section>
<section id="solving-primal-problem">
<h2><span class="section-number">16.4. </span>Solving primal problem<a class="headerlink" href="#solving-primal-problem" title="Permalink to this heading">#</a></h2>
<p>The following method assembles  our components in order to solve the primal problem.</p>
<p>First, if matches are perfect pairs, we store the on-diagonal matching and create an off-diagonal instance with the residual marginals.</p>
<p>Then we compute the set of layers of the residual distributions.</p>
<p>Finally, we solve each layer and put together  matchings within each layer with the on-diagonal matchings.</p>
<p>We then return the full matching, the off-diagonal matching, and the off-diagonal instance.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">solve_primal_pb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Compute on-diagonal matching, create new instance with resitual types</span>
    <span class="n">off_diagoff_diagonal</span><span class="p">,</span> <span class="n">match_tuple</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_offD_onD_matching</span><span class="p">()</span>
    <span class="n">nonzero_id_x</span><span class="p">,</span> <span class="n">nonzero_id_y</span><span class="p">,</span> <span class="n">matching_diag</span> <span class="o">=</span> <span class="n">match_tuple</span>
    
    <span class="c1"># Compute layers</span>
    <span class="n">layers_list</span><span class="p">,</span> <span class="n">layers_mass</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">off_diagoff_diagonal</span><span class="o">.</span><span class="n">find_layers</span><span class="p">()</span>

    <span class="c1"># Solve layers to compute off-diagonal matching</span>
    <span class="n">matching_off_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">off_diagoff_diagonal</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ell</span><span class="p">,</span> <span class="n">layer</span>  <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers_list</span><span class="p">):</span>
        <span class="n">V_i_j</span> <span class="o">=</span> <span class="n">off_diagoff_diagonal</span><span class="o">.</span><span class="n">solve_bellman_eqs</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span>
        <span class="n">matching_off_diag</span> <span class="o">+=</span> <span class="n">layers_mass</span><span class="p">[</span><span class="n">ell</span><span class="p">]</span> \
                    <span class="o">*</span> <span class="n">off_diagoff_diagonal</span><span class="o">.</span><span class="n">find_layer_matching</span><span class="p">(</span><span class="n">V_i_j</span><span class="p">,</span> <span class="n">layer</span><span class="p">)</span>

    <span class="c1"># Add together on- and off-diagonal matchings</span>
    <span class="n">matching</span> <span class="o">=</span> <span class="n">matching_diag</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">matching</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">nonzero_id_x</span><span class="p">,</span> <span class="n">nonzero_id_y</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">matching_off_diag</span>

    <span class="k">return</span> <span class="n">matching</span><span class="p">,</span> <span class="n">matching_off_diag</span><span class="p">,</span> <span class="n">off_diagoff_diagonal</span>

<span class="n">ConcaveCostOT</span><span class="o">.</span><span class="n">solve_primal_pb</span> <span class="o">=</span> <span class="n">solve_primal_pb</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">matching</span><span class="p">,</span> <span class="n">matching_off_diag</span><span class="p">,</span> <span class="n">off_diagoff_diagonal</span> <span class="o">=</span> <span class="n">example_pb</span><span class="o">.</span><span class="n">solve_primal_pb</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We implement a similar method that  adopts the DSS algorithm</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">solve_primal_DSS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Compute on-diagonal matching, create new instance with resitual types</span>
    <span class="n">off_diagoff_diagonal</span><span class="p">,</span> <span class="n">match_tuple</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_offD_onD_matching</span><span class="p">()</span>
    <span class="n">nonzero_id_x</span><span class="p">,</span> <span class="n">nonzero_id_y</span><span class="p">,</span> <span class="n">matching_diag</span> <span class="o">=</span> <span class="n">match_tuple</span>

    <span class="c1"># Find layers</span>
    <span class="n">layers</span><span class="p">,</span> <span class="n">layers_mass</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">off_diagoff_diagonal</span><span class="o">.</span><span class="n">find_layers</span><span class="p">()</span>

    <span class="c1"># Solve layers to compute off-diagonal matching</span>
    <span class="n">matching_off_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">off_diagoff_diagonal</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ell</span><span class="p">,</span> <span class="n">layer</span>  <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
        <span class="n">matching_off_diag</span> <span class="o">+=</span> <span class="n">layers_mass</span><span class="p">[</span><span class="n">ell</span><span class="p">]</span> \
                          <span class="o">*</span> <span class="n">off_diagoff_diagonal</span><span class="o">.</span><span class="n">find_layer_matching_DSS</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span>

    <span class="c1"># Add together on- and off-diagonal matchings</span>
    <span class="n">matching</span> <span class="o">=</span> <span class="n">matching_diag</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">matching</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">nonzero_id_x</span><span class="p">,</span> <span class="n">nonzero_id_y</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">matching_off_diag</span>

    <span class="k">return</span> <span class="n">matching</span><span class="p">,</span> <span class="n">matching_off_diag</span><span class="p">,</span> <span class="n">off_diagoff_diagonal</span>

<span class="n">ConcaveCostOT</span><span class="o">.</span><span class="n">solve_primal_DSS</span> <span class="o">=</span> <span class="n">solve_primal_DSS</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">DSS_tuple</span> <span class="o">=</span> <span class="n">example_pb</span><span class="o">.</span><span class="n">solve_primal_DSS</span><span class="p">()</span>
<span class="n">matching_DSS</span><span class="p">,</span> <span class="n">matching_off_diag_DSS</span><span class="p">,</span> <span class="n">off_diagoff_diagonal_DSS</span> <span class="o">=</span> <span class="n">DSS_tuple</span>
</pre></div>
</div>
</div>
</div>
<p>By drawing semicircles joining the matched agents (with distinct types), we can visualize the off-diagonal matching.</p>
<p>In the following figure,  widths and colors of  semicirles indicate relative numbers of agents that  are “transported” along an  arc.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_matching</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matching_off_diag</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span> 
                    <span class="n">add_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_H_z</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scatter</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    
    <span class="c1"># Create the figure and axis</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>

    <span class="c1"># Plot types on the real line</span>
    <span class="k">if</span> <span class="n">scatter</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> 
                    <span class="n">s</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> 
                    <span class="n">s</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

    <span class="c1"># Add labels for X_types and Y_types if add_labels is True</span>
    <span class="k">if</span> <span class="n">add_labels</span><span class="p">:</span>
        <span class="c1"># Remove x-axis ticks</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>

        <span class="c1"># Add labels</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;$x_</span><span class="se">{{</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="si">}</span><span class="se">}}</span><span class="s1">$&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s2">&quot;offset points&quot;</span><span class="p">,</span> 
                        <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">15</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;$y_</span><span class="se">{{</span><span class="si">{</span><span class="n">j</span><span class="w"> </span><span class="si">}</span><span class="se">}}</span><span class="s1">$&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s2">&quot;offset points&quot;</span><span class="p">,</span> 
                        <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">15</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
            
    <span class="c1"># Draw semicircles for each pair of matched types</span>
    <span class="n">matched_types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">matching_off_diag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">matched_types_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">[</span><span class="n">matched_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">matched_types_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">[</span><span class="n">matched_types</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
   
    <span class="n">count</span> <span class="o">=</span> <span class="n">matching_off_diag</span><span class="p">[</span><span class="n">matched_types</span><span class="p">]</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Greys</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">count</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">max_height</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">count</span><span class="p">)):</span>
        <span class="n">width</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">matched_types_x</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">-</span> <span class="n">matched_types_y</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span>
        <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">matched_types_x</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">+</span> <span class="n">matched_types_y</span><span class="p">[</span><span class="nb">iter</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>        
        <span class="n">height</span> <span class="o">=</span> <span class="n">width</span> 
        <span class="n">max_height</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_height</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
        <span class="n">semicircle</span> <span class="o">=</span> <span class="n">patches</span><span class="o">.</span><span class="n">Arc</span><span class="p">((</span><span class="n">center</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> 
                                 <span class="n">theta1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta2</span><span class="o">=</span><span class="mi">180</span><span class="p">,</span> 
                                 <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">count</span><span class="p">[</span><span class="nb">iter</span><span class="p">]],</span> 
                                 <span class="n">lw</span><span class="o">=</span><span class="n">count</span><span class="p">[</span><span class="nb">iter</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.2</span> <span class="o">/</span> <span class="n">count</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">semicircle</span><span class="p">)</span>

    <span class="c1"># Title and layout settings for the main plot</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">((</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="o">.</span><span class="n">ptp</span><span class="p">()</span> <span class="o">/</span> <span class="mi">10</span><span class="p">,</span> 
                <span class="p">(</span><span class="n">max_height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="o">.</span><span class="n">ptp</span><span class="p">()</span><span class="o">*</span><span class="mf">.01</span><span class="p">)</span>  

    <span class="c1"># Plot H_z on the main axis if enabled</span>
    <span class="k">if</span> <span class="n">plot_H_z</span><span class="p">:</span>
        <span class="n">H_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_z</span><span class="p">)</span>  

        <span class="n">step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="bp">self</span><span class="o">.</span><span class="n">support_z</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> 
                                <span class="o">-</span> <span class="mf">.02</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">support_z</span><span class="o">.</span><span class="n">ptp</span><span class="p">()],</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">support_z</span><span class="p">,</span>
                                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">support_z</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> 
                                <span class="o">+</span> <span class="mf">.02</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">support_z</span><span class="o">.</span><span class="n">ptp</span><span class="p">()]))</span>

        <span class="n">H_z</span> <span class="o">=</span> <span class="n">H_z</span><span class="o">/</span><span class="n">H_z</span><span class="o">.</span><span class="n">ptp</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">support_z</span><span class="o">.</span><span class="n">ptp</span><span class="p">()</span> <span class="o">/</span><span class="mi">2</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">H_z</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="c1"># Plot the compressed H_z on the same main x-axis</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> 
                                <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$H_z$&#39;</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s1">&#39;post&#39;</span><span class="p">)</span>
        
        <span class="c1"># Set the y-limit to keep H_z and maximum circle size in the plot</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">H_z</span><span class="p">)</span> <span class="o">-</span> <span class="n">H_z</span><span class="o">.</span><span class="n">ptp</span><span class="p">()</span> <span class="o">*</span><span class="mf">.01</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">H_z</span><span class="p">),</span> <span class="n">max_height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">H_z</span><span class="o">.</span><span class="n">ptp</span><span class="p">()</span> <span class="o">*</span><span class="mf">.01</span><span class="p">)</span> 

        <span class="c1"># Add label and legend for H_z</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;upper right&quot;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">ConcaveCostOT</span><span class="o">.</span><span class="n">plot_matching</span> <span class="o">=</span> <span class="n">plot_matching</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">off_diagoff_diagonal</span><span class="o">.</span><span class="n">plot_matching</span><span class="p">(</span><span class="n">matching_off_diag</span><span class="p">,</span> 
            <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Optimal Matching (off-diagonal)&#39;</span><span class="p">,</span> <span class="n">plot_H_z</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">off_diagoff_diagonal_DSS</span><span class="o">.</span><span class="n">plot_matching</span><span class="p">(</span><span class="n">matching_off_diag_DSS</span><span class="p">,</span> 
            <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Optimal Matching (off-diagonal) with DSS algorithm&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/8d7abc00a2ae3cb85be3f1d7994d683522e5c9fa78299aa11ffbd4b1404edb01.png" src="_images/8d7abc00a2ae3cb85be3f1d7994d683522e5c9fa78299aa11ffbd4b1404edb01.png" />
<img alt="_images/f2bb710585e5c6948ca3b41c24bb00005ec785eba4f9b9c40d1b1f2a11102afc.png" src="_images/f2bb710585e5c6948ca3b41c24bb00005ec785eba4f9b9c40d1b1f2a11102afc.png" />
</div>
</div>
<section id="verify-with-linear-programming">
<h3><span class="section-number">16.4.1. </span>Verify with linear programming<a class="headerlink" href="#verify-with-linear-programming" title="Permalink to this heading">#</a></h3>
<p>Let’s verify some of the proceeding findings using linear programming.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">solve_1to1</span><span class="p">(</span><span class="n">c_i_j</span><span class="p">,</span> <span class="n">n_x</span><span class="p">,</span> <span class="n">m_y</span><span class="p">,</span> <span class="n">return_dual</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">c_i_j</span><span class="p">)</span>

    <span class="c1"># Constraint matrix </span>
    <span class="n">M_z_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">m</span><span class="p">)),</span>
                       <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">m</span><span class="p">))])</span>
    <span class="c1"># Constraint vector</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">n_x</span><span class="p">,</span> <span class="n">m_y</span><span class="p">))</span>
    
    <span class="c1"># Solve the linear programming problem using linprog from scipy</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">linprog</span><span class="p">(</span><span class="n">c_i_j</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">A_eq</span><span class="o">=</span><span class="n">M_z_a</span><span class="p">,</span> <span class="n">b_eq</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> 
                        <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;highs&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_dual</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]),</span> 
                <span class="n">result</span><span class="o">.</span><span class="n">eqlin</span><span class="o">.</span><span class="n">marginals</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mu_x_y_LP</span> <span class="o">=</span> <span class="n">solve_1to1</span><span class="p">(</span><span class="n">example_pb</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">,</span>
                <span class="n">example_pb</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span>
                <span class="n">example_pb</span><span class="o">.</span><span class="n">m_y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Value of LP (scipy): </span><span class="si">{</span><span class="p">(</span><span class="n">mu_x_y_LP</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">example_pb</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Value (plain Bellman equations): </span><span class="si">{</span><span class="p">(</span><span class="n">matching</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">example_pb</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Value (DSS): </span><span class="si">{</span><span class="p">(</span><span class="n">matching_DSS</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">example_pb</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Value of LP (scipy): 143.45490363125705
Value (plain Bellman equations): 143.45490363125705
Value (DSS): 143.45490363125705
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="examples">
<h2><span class="section-number">16.5. </span>Examples<a class="headerlink" href="#examples" title="Permalink to this heading">#</a></h2>
<section id="example-1">
<h3><span class="section-number">16.5.1. </span>Example 1<a class="headerlink" href="#example-1" title="Permalink to this heading">#</a></h3>
<p>We study optimal transport problems on the real line with cost <span class="math notranslate nohighlight">\(c(x,y)= h(|x-y|)\)</span> for a strictly concave and increasing function <span class="math notranslate nohighlight">\(h: \mathbb{R}_+ \rightarrow \mathbb{R}_+.\)</span></p>
<p>The outcome  is called <em>composite sorting</em>.</p>
<p>Here, we  will focus on <span class="math notranslate nohighlight">\(c(x,y)=|x-y|^{\frac{1}{\zeta}}\)</span> for <span class="math notranslate nohighlight">\(\zeta&gt;1\)</span></p>
<p>To appreciate  differences with <em>positive assortative matching</em> (PAM) note that the latter is induced by a cost of the form <span class="math notranslate nohighlight">\( h(x-y)\)</span> for some strictly convex <span class="math notranslate nohighlight">\(h: \mathbb{R} \rightarrow \mathbb{R}_+.\)</span></p>
<p>See Santambrogio 2015, Ch. 2.2.</p>
<p>For example, the cost function <span class="math notranslate nohighlight">\(|x-y|^{p},p&gt;1\)</span> induces PAM.</p>
<p>On the other hand, <em>negative assortative matching</em> (NAM) arises if <span class="math notranslate nohighlight">\(c(x,y)= h(x-y)\)</span> with  <span class="math notranslate nohighlight">\(h: \mathbb{R} \rightarrow \mathbb{R}_+\)</span> strictly concave.</p>
<p>For example,  the cost function <span class="math notranslate nohighlight">\(-|x-y|^{p},p&gt;1,\)</span> induces NAM.</p>
<p>Thus, NAM corresponds to a matching that <em>maximizes</em> a transport problem criterion with <em>gain</em> function <span class="math notranslate nohighlight">\(g(x,y)=|x-y|^{p}\)</span>.</p>
<p>Note how PAM and NAM differ from  <strong>composite sorting</strong></p>
<p><strong>Composite sorting</strong>   is  induced by a cost that is the composition of a strictly concave increasing function <span class="math notranslate nohighlight">\(h\)</span> and a convex function <span class="math notranslate nohighlight">\(|\cdot|\)</span> applied to  displacement <span class="math notranslate nohighlight">\(x-y.\)</span></p>
<p>Different functions <span class="math notranslate nohighlight">\(h\)</span> potentially induce different matchings.</p>
<p>The following example shows that composite matching can feature both positive and negative assortative patterns.</p>
<p>Suppose that  there are two agents per side and types</p>
<div class="math notranslate nohighlight">
\[ 
\textcolor{blue}{x_0} &lt;  \textcolor{red}{y_0} &lt;  \textcolor{blue}{x_1} &lt;  \textcolor{red}{y_1}
\]</div>
<p>There are  two feasible matchings, one corresponding  to PAM, the other to  NAM.</p>
<ul class="simple">
<li><p>The first features two displacements <span class="math notranslate nohighlight">\(|\textcolor{blue}{x_0} -  \textcolor{red}{y_0}| ,|  \textcolor{blue}{x_1} -  \textcolor{red}{y_1}|\)</span></p></li>
<li><p>The second features a large displacement <span class="math notranslate nohighlight">\(|\textcolor{blue}{x_0} -  \textcolor{red}{y_1}| \)</span> and a small displacement <span class="math notranslate nohighlight">\(|  \textcolor{blue}{x_1} -  \textcolor{red}{y_0}|.\)</span></p></li>
</ul>
<p>Evidently,</p>
<ul class="simple">
<li><p>PAM corresponds to the matching with two medium side displacement because the correponding cost is strictly convex and increasing in the the displacement.</p></li>
<li><p>NAM corresponds to the matching with a small displacement and a large displacement because the gain is strictly convex and increasing in the displacement.</p></li>
</ul>
<p>In this example, composite sorting ends up coinciding  with NAM, but this is something of a coincidence</p>
<ul class="simple">
<li><p>Thus,  note that  in composite matching the cost function is strictly concave and increasing in the displacement.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">p</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">ζ</span> <span class="o">=</span> <span class="mi">2</span>

<span class="c1"># Solve composite sorting problem</span>
<span class="n">example_1</span> <span class="o">=</span> <span class="n">ConcaveCostOT</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">]),</span> 
                          <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">10</span><span class="p">]),</span>
                          <span class="n">ζ</span><span class="o">=</span><span class="n">ζ</span><span class="p">)</span>
<span class="n">matching_CS</span><span class="p">,</span> <span class="n">_</span> <span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">example_1</span><span class="o">.</span><span class="n">solve_primal_DSS</span><span class="p">()</span>

<span class="c1"># Solve PAM and NAM</span>
<span class="c1"># I use the linear programs to compute PAM and NAM,</span>
<span class="c1"># but of course they can be computed directly</span>

<span class="n">convex_cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">example_1</span><span class="o">.</span><span class="n">X_types</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">example_1</span><span class="o">.</span><span class="n">Y_types</span><span class="p">[</span><span class="kc">None</span><span class="p">,:])</span><span class="o">**</span><span class="n">p</span>

<span class="c1">#PAM: |x-y|^p , p&gt;1</span>
<span class="n">matching_PAM</span> <span class="o">=</span> <span class="n">solve_1to1</span><span class="p">(</span><span class="n">convex_cost</span><span class="p">,</span> <span class="n">example_1</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="n">example_1</span><span class="o">.</span><span class="n">m_y</span><span class="p">)</span>

<span class="c1">#NAM: -|x-y|^p , p&gt;1</span>
<span class="n">matching_NAM</span> <span class="o">=</span> <span class="n">solve_1to1</span><span class="p">(</span><span class="o">-</span><span class="n">convex_cost</span><span class="p">,</span> <span class="n">example_1</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="n">example_1</span><span class="o">.</span><span class="n">m_y</span><span class="p">)</span>

<span class="c1"># Plot the matchings</span>
<span class="n">example_1</span><span class="o">.</span><span class="n">plot_matching</span><span class="p">(</span><span class="n">matching_CS</span><span class="p">,</span> 
                <span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Composite Sorting: $|x-y|^</span><span class="se">{{</span><span class="s1">1/</span><span class="si">{</span><span class="n">ζ</span><span class="si">}</span><span class="se">}}</span><span class="s1">$&#39;</span><span class="p">,</span> 
                <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">add_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">example_1</span><span class="o">.</span><span class="n">plot_matching</span><span class="p">(</span><span class="n">matching_PAM</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;PAM&#39;</span><span class="p">,</span> 
                <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">add_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/76bf4acd5ff4b3e8cedc4ec296981b25d0f8d0b30cd19e153602e3db2e20283c.png" src="_images/76bf4acd5ff4b3e8cedc4ec296981b25d0f8d0b30cd19e153602e3db2e20283c.png" />
<img alt="_images/314cbae0b10533b6264267e73ac8ccba96334b0f461df62d13f95616fd0bb3be.png" src="_images/314cbae0b10533b6264267e73ac8ccba96334b0f461df62d13f95616fd0bb3be.png" />
</div>
</div>
<p>To explore the coincidental resemblence to a NAM outcome,  let’s  shift left type <span class="math notranslate nohighlight">\(\textcolor{red}{y_0} \)</span> while  keeping it in between <span class="math notranslate nohighlight">\(\textcolor{blue}{x_0}\)</span> and <span class="math notranslate nohighlight">\(\textcolor{blue}{x_1}\)</span>.</p>
<p>PAM and NAM are invariant to any such shift.</p>
<p>However, for a large enough shift, composite sorting now coindices with PAM.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">ζ</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">p</span> <span class="o">=</span> <span class="mi">2</span>

<span class="c1"># Solve composite sorting problem</span>
<span class="n">example_1</span> <span class="o">=</span> <span class="n">ConcaveCostOT</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">]),</span> 
                          <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span> <span class="p">,</span>
                           <span class="n">ζ</span> <span class="o">=</span> <span class="n">ζ</span><span class="p">)</span>
<span class="n">matching_CS</span><span class="p">,</span> <span class="n">_</span> <span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">example_1</span><span class="o">.</span><span class="n">solve_primal_DSS</span><span class="p">()</span>

<span class="c1"># Solve PAM and NAM</span>
<span class="n">convex_cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">example_1</span><span class="o">.</span><span class="n">X_types</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">example_1</span><span class="o">.</span><span class="n">Y_types</span><span class="p">[</span><span class="kc">None</span><span class="p">,:])</span><span class="o">**</span><span class="n">p</span>

<span class="n">matching_PAM</span> <span class="o">=</span> <span class="n">solve_1to1</span><span class="p">(</span><span class="n">convex_cost</span><span class="p">,</span> <span class="n">example_1</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="n">example_1</span><span class="o">.</span><span class="n">m_y</span><span class="p">)</span>
<span class="n">matching_NAM</span> <span class="o">=</span> <span class="n">solve_1to1</span><span class="p">(</span><span class="o">-</span><span class="n">convex_cost</span><span class="p">,</span> <span class="n">example_1</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="n">example_1</span><span class="o">.</span><span class="n">m_y</span><span class="p">)</span>

<span class="c1"># Plot the matchings</span>
<span class="n">example_1</span><span class="o">.</span><span class="n">plot_matching</span><span class="p">(</span><span class="n">matching_CS</span><span class="p">,</span> 
        <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Composite Sorting: $|x-y|^</span><span class="se">{{</span><span class="s1">1/</span><span class="si">{</span><span class="n">ζ</span><span class="si">}</span><span class="se">}}</span><span class="s1">$&#39;</span><span class="p">,</span> 
        <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">add_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">example_1</span><span class="o">.</span><span class="n">plot_matching</span><span class="p">(</span><span class="n">matching_PAM</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;PAM&#39;</span><span class="p">,</span> 
        <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">add_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">example_1</span><span class="o">.</span><span class="n">plot_matching</span><span class="p">(</span><span class="n">matching_NAM</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;NAM&#39;</span><span class="p">,</span> 
        <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">add_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/c6696acbfc993514ee068bb9c5e24f96aed376b2948546a9ee661b38b7ffe32c.png" src="_images/c6696acbfc993514ee068bb9c5e24f96aed376b2948546a9ee661b38b7ffe32c.png" />
<img alt="_images/3884e2cab5aa87af6deace4a68ef3da68694851464f05a010a8f63460afa5786.png" src="_images/3884e2cab5aa87af6deace4a68ef3da68694851464f05a010a8f63460afa5786.png" />
<img alt="_images/7aee87acf03be858b26b895b5cd91766c2818a25fcac7930c2026fa3716189a8.png" src="_images/7aee87acf03be858b26b895b5cd91766c2818a25fcac7930c2026fa3716189a8.png" />
</div>
</div>
<p>Finally, notice that the  <strong>Monge problem</strong>  cost function <span class="math notranslate nohighlight">\(|x-y|\)</span>  equals the limit of the  composite sorting cost <span class="math notranslate nohighlight">\(|x-y|^{1/\zeta}\)</span> as <span class="math notranslate nohighlight">\(\zeta \downarrow 1\)</span> and also  the limit of <span class="math notranslate nohighlight">\(|x-y|^p\)</span> as <span class="math notranslate nohighlight">\(p \downarrow 1.\)</span></p>
<p>Evidently, the Monge problem is solved by both the PAM and the composite sorting assignment that arises for <span class="math notranslate nohighlight">\(\zeta \downarrow 1.\)</span></p>
<p>In the following example, the Monge cost of the composite sorting assignment equals the Monge cost of PAM.</p>
<p>Consequently, it is optimal for the Monge problem.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>

<span class="n">ζ</span> <span class="o">=</span> <span class="mf">1.01</span>
<span class="n">p</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">X_types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
<span class="n">Y_types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>

<span class="c1"># Solve composite sorting problem</span>
<span class="n">example_1</span> <span class="o">=</span> <span class="n">ConcaveCostOT</span><span class="p">(</span><span class="n">X_types</span><span class="p">,</span> <span class="n">Y_types</span><span class="p">,</span> <span class="n">ζ</span><span class="o">=</span><span class="n">ζ</span><span class="p">)</span>

<span class="n">matching_CS</span><span class="p">,</span> <span class="n">_</span> <span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">example_1</span><span class="o">.</span><span class="n">solve_primal_DSS</span><span class="p">()</span>

<span class="c1"># Solve PAM and NAM</span>
<span class="n">convex_cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">X_types</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">Y_types</span><span class="p">[</span><span class="kc">None</span><span class="p">,:])</span><span class="o">**</span> <span class="n">p</span>

<span class="n">matching_PAM</span> <span class="o">=</span> <span class="n">solve_1to1</span><span class="p">(</span><span class="n">convex_cost</span><span class="p">,</span> <span class="n">example_1</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="n">example_1</span><span class="o">.</span><span class="n">m_y</span><span class="p">)</span>
<span class="n">matching_NAM</span> <span class="o">=</span> <span class="n">solve_1to1</span><span class="p">(</span><span class="o">-</span><span class="n">convex_cost</span><span class="p">,</span> <span class="n">example_1</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="n">example_1</span><span class="o">.</span><span class="n">m_y</span><span class="p">)</span>


<span class="n">example_1</span><span class="o">.</span><span class="n">plot_matching</span><span class="p">(</span><span class="n">matching_CS</span><span class="p">,</span> 
            <span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Composite Sorting: $|x-y|^</span><span class="se">{{</span><span class="s1">1/</span><span class="si">{</span><span class="n">ζ</span><span class="si">}</span><span class="se">}}</span><span class="s1">$&#39;</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">example_1</span><span class="o">.</span><span class="n">plot_matching</span><span class="p">(</span><span class="n">matching_PAM</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;PAM&#39;</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span> 

<span class="n">monge_cost_comp</span> <span class="o">=</span> <span class="p">(</span><span class="n">matching_CS</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">X_types</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">Y_types</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="n">monge_cost_PAM</span> <span class="o">=</span> <span class="p">(</span><span class="n">matching_PAM</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">example_1</span><span class="o">.</span><span class="n">X_types</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> 
                               <span class="o">-</span> <span class="n">example_1</span><span class="o">.</span><span class="n">Y_types</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Monge cost of the composite matching assignment:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">monge_cost_comp</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Monge cost of PAM:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">monge_cost_PAM</span><span class="p">)</span>   
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Monge cost of the composite matching assignment:
10.530287849572634
Monge cost of PAM:
10.530287849572636
</pre></div>
</div>
<img alt="_images/d73de004a7920eccb27d6272817847e29711048cbe3ced7538b3c43cc9b36c2e.png" src="_images/d73de004a7920eccb27d6272817847e29711048cbe3ced7538b3c43cc9b36c2e.png" />
<img alt="_images/7dcbcdcafcc8e7724bd1e2786cdac93374ed7a5b361669bcdac7649fbef31d4e.png" src="_images/7dcbcdcafcc8e7724bd1e2786cdac93374ed7a5b361669bcdac7649fbef31d4e.png" />
</div>
</div>
</section>
<section id="example-2">
<h3><span class="section-number">16.5.2. </span>Example 2<a class="headerlink" href="#example-2" title="Permalink to this heading">#</a></h3>
<p>The following example has five agents per side.</p>
<p>The composite sorting assignment differs from both PAM and NAM.</p>
<p>Composite sorting features a hierarchical structure, with each hierarchy positively sorted.</p>
<p>Indeed, consider the composite sorting assignment and note that</p>
<ul class="simple">
<li><p>the only arcs <em>visible from above</em> are the ones corresponding to pairings <span class="math notranslate nohighlight">\((\textcolor{blue}{x_0},\textcolor{red}{y_3})\)</span> and <span class="math notranslate nohighlight">\((\textcolor{red}{y_4},\textcolor{blue}{x_4});\)</span></p></li>
<li><p>after removing these agents, the only arcs visible from above correspond to <span class="math notranslate nohighlight">\((\textcolor{blue}{x_1},\textcolor{red}{y_1})\)</span> and <span class="math notranslate nohighlight">\((\textcolor{blue}{x_3},\textcolor{red}{y_2})\)</span> ;</p></li>
<li><p>after removing these agents, the only arc/pairing left is <span class="math notranslate nohighlight">\((\textcolor{blue}{x_2},\textcolor{red}{y_0}).\)</span></p></li>
</ul>
<p>Note that, at each iteration, the partial assignment corresponding to the arcs visible from above features positive assortativeness.</p>
<p>Another distinct feature of composite matching  stands out from the figures:</p>
<ul class="simple">
<li><p><strong>arcs do not intersect</strong></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">ζ</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">p</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">X_types_example_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>
<span class="n">Y_types_example_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">])</span> 

<span class="c1"># Solve composite sorting problem</span>
<span class="n">example_2</span> <span class="o">=</span> <span class="n">ConcaveCostOT</span><span class="p">(</span><span class="n">X_types_example_2</span><span class="p">,</span> <span class="n">Y_types_example_2</span><span class="p">,</span> <span class="n">ζ</span><span class="o">=</span><span class="n">ζ</span><span class="p">)</span>

<span class="n">matching_CS</span><span class="p">,</span> <span class="n">_</span> <span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">example_2</span><span class="o">.</span><span class="n">solve_primal_DSS</span><span class="p">()</span>

<span class="c1"># Solve PAM and NAM</span>
<span class="n">convex_cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">X_types_example_2</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">Y_types_example_2</span><span class="p">[</span><span class="kc">None</span><span class="p">,:])</span><span class="o">**</span> <span class="n">p</span>

<span class="n">matching_PAM</span> <span class="o">=</span> <span class="n">solve_1to1</span><span class="p">(</span><span class="n">convex_cost</span><span class="p">,</span> <span class="n">example_2</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="n">example_2</span><span class="o">.</span><span class="n">m_y</span><span class="p">)</span>
<span class="n">matching_NAM</span> <span class="o">=</span> <span class="n">solve_1to1</span><span class="p">(</span><span class="o">-</span><span class="n">convex_cost</span><span class="p">,</span> <span class="n">example_2</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="n">example_2</span><span class="o">.</span><span class="n">m_y</span><span class="p">)</span>


<span class="n">example_2</span><span class="o">.</span><span class="n">plot_matching</span><span class="p">(</span><span class="n">matching_CS</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Composite Sorting: $|x-y|^{1/2}$&#39;</span><span class="p">,</span> 
                        <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">add_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">example_2</span><span class="o">.</span><span class="n">plot_matching</span><span class="p">(</span><span class="n">matching_PAM</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;PAM&#39;</span><span class="p">,</span> 
                        <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">add_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
<span class="n">example_2</span><span class="o">.</span><span class="n">plot_matching</span><span class="p">(</span><span class="n">matching_NAM</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;NAM&#39;</span><span class="p">,</span> 
                        <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">add_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/d94cc60246babf16b0e0cade6f6121b3218fd11309756cd5b418ae445e611658.png" src="_images/d94cc60246babf16b0e0cade6f6121b3218fd11309756cd5b418ae445e611658.png" />
<img alt="_images/3200301a590109f4ba8a0899200daf7e0ab6f1ee2e9179fe032846198bb8c342.png" src="_images/3200301a590109f4ba8a0899200daf7e0ab6f1ee2e9179fe032846198bb8c342.png" />
<img alt="_images/6cceae42a95739b2de88292355efaea0ae41290df3feed086e8ad8ff10e20ff7.png" src="_images/6cceae42a95739b2de88292355efaea0ae41290df3feed086e8ad8ff10e20ff7.png" />
</div>
</div>
</section>
<section id="example-3">
<h3><span class="section-number">16.5.3. </span>Example 3<a class="headerlink" href="#example-3" title="Permalink to this heading">#</a></h3>
<p><span id="id8">[<a class="reference internal" href="zreferences.html#id3" title="Job Boerma, Aleh Tsyvinski, Ruodu Wang, and Zhenyuan Zhang. Composite sorting. Technical Report, University of Wisconsin, 2024.">Boerma <em>et al.</em>, 2024</a>]</span> provide the following  example.</p>
<p>There are four agents per side and three types per side (so the problem is not unitary, as opposed to the examples above).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_types_example_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span>
<span class="n">Y_types_example_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span> 
<span class="n">n_x_example_3</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">m_y_example_3</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span> <span class="nb">int</span><span class="p">)</span>


<span class="n">example_3</span> <span class="o">=</span> <span class="n">ConcaveCostOT</span><span class="p">(</span><span class="n">X_types_example_3</span><span class="p">,</span> <span class="n">Y_types_example_3</span><span class="p">,</span> 
                          <span class="n">n_x_example_3</span><span class="p">,</span> <span class="n">m_y_example_3</span><span class="p">,</span> <span class="n">ζ</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">example_3</span><span class="o">.</span><span class="n">plot_marginals</span><span class="p">(</span><span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/7b79f32bc467531da1a68950eefde53aaa7553190552253a4c33b25e9e019f33.png" src="_images/7b79f32bc467531da1a68950eefde53aaa7553190552253a4c33b25e9e019f33.png" />
</div>
</div>
<p>In the case of positive assortative matching (PAM), the two agents with lowest value <span class="math notranslate nohighlight">\(\textcolor{blue}{x_0} \)</span> are matched with the lowest valued agents on the other side <span class="math notranslate nohighlight">\(\textcolor{red}{y_0},\textcolor{red}{y_1}.\)</span></p>
<p>Similarly, the agents with highest value <span class="math notranslate nohighlight">\(\textcolor{red}{y_2} \)</span> are matched with the highest valued types on the other side, <span class="math notranslate nohighlight">\(\textcolor{blue}{x_1}\)</span> and <span class="math notranslate nohighlight">\(\textcolor{blue}{x_2}. \)</span></p>
<p>Composite sorting features both negative and positive sorting patterns: agents of type <span class="math notranslate nohighlight">\(\textcolor{blue}{x_0}\)</span> are matched with both the bottom <span class="math notranslate nohighlight">\(\textcolor{red}{y_0}\)</span> and the top <span class="math notranslate nohighlight">\(\textcolor{red}{y_2}\)</span> of the distribution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">matching_CS</span><span class="p">,</span> <span class="n">_</span> <span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">example_3</span><span class="o">.</span><span class="n">solve_primal_DSS</span><span class="p">()</span>

<span class="n">convex_cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">example_3</span><span class="o">.</span><span class="n">X_types</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">example_3</span><span class="o">.</span><span class="n">Y_types</span><span class="p">[</span><span class="kc">None</span><span class="p">,:])</span><span class="o">**</span><span class="mi">2</span>
<span class="n">matching_PAM</span> <span class="o">=</span> <span class="n">solve_1to1</span><span class="p">(</span><span class="n">convex_cost</span><span class="p">,</span> <span class="n">example_3</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="n">example_3</span><span class="o">.</span><span class="n">m_y</span><span class="p">)</span>
<span class="n">matching_NAM</span> <span class="o">=</span> <span class="n">solve_1to1</span><span class="p">(</span><span class="o">-</span><span class="n">convex_cost</span><span class="p">,</span> <span class="n">example_3</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span> <span class="n">example_3</span><span class="o">.</span><span class="n">m_y</span><span class="p">)</span>

<span class="n">example_3</span><span class="o">.</span><span class="n">plot_matching</span><span class="p">(</span><span class="n">matching_PAM</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;PAM&#39;</span><span class="p">,</span> 
                        <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">add_labels</span><span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">example_3</span><span class="o">.</span><span class="n">plot_matching</span><span class="p">(</span><span class="n">matching_CS</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Composite Sorting&#39;</span><span class="p">,</span> 
                        <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">add_labels</span><span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">example_3</span><span class="o">.</span><span class="n">plot_matching</span><span class="p">(</span><span class="n">matching_NAM</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;NAM&#39;</span><span class="p">,</span> 
                        <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">add_labels</span><span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/43cc8a6e16d22f455158729f36460b893c3e8e4493120a46e31ce8d4972faa37.png" src="_images/43cc8a6e16d22f455158729f36460b893c3e8e4493120a46e31ce8d4972faa37.png" />
<img alt="_images/89292f595c87ba67b74e5ea6add5cee6b31520a17cd4ca6e36f9441d6fc41a4f.png" src="_images/89292f595c87ba67b74e5ea6add5cee6b31520a17cd4ca6e36f9441d6fc41a4f.png" />
<img alt="_images/07cc70c415acd249dbff07bc3042db5e4936ec2a2dae8cbc37401399b925b907.png" src="_images/07cc70c415acd249dbff07bc3042db5e4936ec2a2dae8cbc37401399b925b907.png" />
</div>
</div>
</section>
</section>
<section id="dual-solution">
<h2><span class="section-number">16.6. </span>Dual Solution<a class="headerlink" href="#dual-solution" title="Permalink to this heading">#</a></h2>
<p>Let’s recall the formulation</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
V_P = \min_{\mu \geq 0}&amp; \sum_{(x,y) \in X \times Y} \mu_{xy}c_{xy} \\
\text{s.t. }&amp; \sum_{x \in X} \mu_{xy} = n_x \\
&amp; \sum_{y \in Y} \mu_{xy} = m_y 
\end{aligned}
\end{split}\]</div>
<p>The <em>dual problem</em> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
V_D = \max_{\phi,\psi}&amp; \sum_{x \in X }n_x \phi_x + \sum_{y \in Y} m_y \psi_y \\
\text{s.t. }&amp;  \phi_x + \psi_y \leq c_{xy}
\end{aligned}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\((\phi , \psi) \)</span> are dual variables, which can be interpreted as shadow cost of agents in <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span>, respectively.</p>
<p>Since the dual is feasible and bounded,  <span class="math notranslate nohighlight">\(V_P = V_D\)</span> (<em>strong duality</em> prevails).</p>
<p>Assume now that <span class="math notranslate nohighlight">\(y_{xy} = \alpha_x + \gamma_y - c_{xy}\)</span> is the output generated by matching <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y.\)</span></p>
<p>It includes the sum of <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> specific amenities/outputs minus the cost <span class="math notranslate nohighlight">\(c_{xy}.\)</span></p>
<p>Then we  can formulate the following problem and its dual</p>
<div class="math notranslate nohighlight">
\[\begin{split}
 \begin{aligned}
W_P = \max_{\mu \geq 0}&amp; \sum_{(x,y) \in X \times Y} \mu_{xy}y_{xy} \\
\text{s.t. }&amp; \sum_{x \in X} \mu_{xy} = n_x \\
&amp; \sum_{y \in Y} \mu_{xy} = m_y 
\end{aligned}
\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
 W_D = \min_{u,v}&amp; \sum_{x \in X }n_x u_x + \sum_{y \in Y} m_y v_y \\
\text{s.t. }&amp;  u_x + v_y \geq y_{xy}
\end{aligned}
\end{split}\]</div>
<p>Given the constraints, the primal problem <span class="math notranslate nohighlight">\(W_P\)</span> does not depend on <span class="math notranslate nohighlight">\(\alpha,\gamma\)</span> and it has the same solutions as the cost minimization problem <span class="math notranslate nohighlight">\(V_P\)</span>.</p>
<p>The values are related by <span class="math notranslate nohighlight">\(W_P =  \sum_{x \in X}n_x \alpha_x +  \sum_{y \in Y}m_y \gamma_y - V_P.\)</span></p>
<p>The dual solutions of <span class="math notranslate nohighlight">\(V_D\)</span> and <span class="math notranslate nohighlight">\(W_D\)</span> are related by <span class="math notranslate nohighlight">\(u_x = \alpha_x - \phi_x\)</span> and <span class="math notranslate nohighlight">\(v_y = \gamma_y - \psi_y.\)</span></p>
<p>The dual solution <span class="math notranslate nohighlight">\((u,v)\)</span> of <span class="math notranslate nohighlight">\(W_D\)</span> can be interpreted as equilibrium utilities of the agents, which include the individual specific amenities and equilibrium shadow costs.</p>
<p><span id="id9">[<a class="reference internal" href="zreferences.html#id3" title="Job Boerma, Aleh Tsyvinski, Ruodu Wang, and Zhenyuan Zhang. Composite sorting. Technical Report, University of Wisconsin, 2024.">Boerma <em>et al.</em>, 2024</a>]</span> propose an efficient method to compute the dual variables from the optimal matching (primal solution) in the case of composite sorting.</p>
<p>Let’s generate an instance and compute the optimal matching.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">num_agents</span> <span class="o">=</span> <span class="mi">8</span>

<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">X_types_assignment_pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">num_agents</span><span class="p">)</span>
<span class="n">Y_types_assignment_pb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">num_agents</span><span class="p">)</span>


<span class="c1"># Create instance of the problem</span>
<span class="n">exam_assign</span> <span class="o">=</span> <span class="n">ConcaveCostOT</span><span class="p">(</span><span class="n">X_types_assignment_pb</span><span class="p">,</span> <span class="n">Y_types_assignment_pb</span><span class="p">)</span>

<span class="c1"># Solve primal problem</span>
<span class="n">assignment</span><span class="p">,</span> <span class="n">assignment_OD</span><span class="p">,</span> <span class="n">exam_assign_OD</span> <span class="o">=</span> <span class="n">exam_assign</span><span class="o">.</span><span class="n">solve_primal_DSS</span><span class="p">()</span>

<span class="c1"># Plot matching</span>
<span class="n">add_labels</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">num_agents</span> <span class="o">&lt;</span> <span class="mi">16</span> <span class="k">else</span> <span class="kc">False</span>
<span class="n">exam_assign_OD</span><span class="o">.</span><span class="n">plot_matching</span><span class="p">(</span><span class="n">assignment_OD</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Composite Sorting&#39;</span><span class="p">,</span> 
                            <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="n">add_labels</span><span class="o">=</span><span class="n">add_labels</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/91be4c65f54a004d6da535a7ae877529974e5a7e97a44de71d8d36338fe7969d.png" src="_images/91be4c65f54a004d6da535a7ae877529974e5a7e97a44de71d8d36338fe7969d.png" />
</div>
</div>
<p>Having computed the optimal matching, we say that a pair <span class="math notranslate nohighlight">\((x_0,y_0)\)</span> is a <em>subpair</em> of a matched pair <span class="math notranslate nohighlight">\((x,y)\)</span> if <span class="math notranslate nohighlight">\(x_0,y_0\)</span> are in the open interval between <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> and the pair <span class="math notranslate nohighlight">\((x_0,y_0)\)</span> is not nested.</p>
<p>The following method computes the subpairs of the optimal matching of the off-diagonal instance.</p>
<p>The output of this method is a dictionary with keys corresponding to matched pairs and an “artificial pair” which collects all arcs which are visible from above.</p>
<p>Values of each key <span class="math notranslate nohighlight">\((x_0,y_0)\)</span> are the subpairs ordered so that the first subpair is the subpair with the <span class="math notranslate nohighlight">\(x\)</span> type closest to <span class="math notranslate nohighlight">\(x_0\)</span> and the last subpair is the subpair with the <span class="math notranslate nohighlight">\(y\)</span> type closest to <span class="math notranslate nohighlight">\(y_0.\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sort_subpairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subpairs</span><span class="p">,</span> <span class="n">x_smaller_y</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>

    <span class="n">x_key</span> <span class="o">=</span> <span class="nb">min</span> <span class="k">if</span> <span class="n">x_smaller_y</span> <span class="k">else</span> <span class="nb">max</span>
    <span class="n">y_key</span> <span class="o">=</span> <span class="nb">max</span> <span class="k">if</span> <span class="n">x_smaller_y</span> <span class="k">else</span> <span class="nb">min</span>

    <span class="n">first_pair</span> <span class="o">=</span> <span class="n">x_key</span><span class="p">(</span><span class="n">subpairs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
    <span class="n">last_pair</span> <span class="o">=</span> <span class="n">y_key</span><span class="p">(</span><span class="n">subpairs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

    <span class="n">intermediate_pairs</span> <span class="o">=</span> <span class="p">[</span><span class="n">pair</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">subpairs</span> 
                            <span class="k">if</span> <span class="n">pair</span> <span class="o">!=</span> <span class="n">first_pair</span> <span class="ow">and</span> <span class="n">pair</span> <span class="o">!=</span> <span class="n">last_pair</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">first_pair</span><span class="p">]</span> <span class="o">+</span> <span class="n">intermediate_pairs</span> <span class="o">+</span> <span class="p">[</span><span class="n">last_pair</span><span class="p">]</span>

<span class="n">ConcaveCostOT</span><span class="o">.</span><span class="n">sort_subpairs</span> <span class="o">=</span> <span class="n">sort_subpairs</span>

<span class="k">def</span> <span class="nf">find_subpairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matching</span><span class="p">,</span> <span class="n">return_pairs_between</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        
    <span class="c1"># Create set of matched pairs of types and add an artificial pair </span>
    <span class="n">matched_pairs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">matching</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)))</span> 

    <span class="c1"># Initialize dictionary to store subpairs</span>
    <span class="n">subpairs</span> <span class="o">=</span> <span class="p">{}</span> 
    <span class="n">pairs_between</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Find subpairs (both nested and non-nested) for each matched pair </span>
    <span class="k">for</span> <span class="n">matched_pair</span> <span class="ow">in</span> <span class="n">matched_pairs</span> <span class="o">|</span> <span class="p">{</span><span class="s1">&#39;artificial_pair&#39;</span><span class="p">}:</span>
        <span class="c1"># Determine the interval of the matched pair</span>
        <span class="k">if</span> <span class="n">matched_pair</span> <span class="o">!=</span> <span class="s1">&#39;artificial_pair&#39;</span><span class="p">:</span>
            <span class="n">min_type</span><span class="p">,</span> <span class="n">max_type</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">[</span><span class="n">matched_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> 
                                         <span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">[</span><span class="n">matched_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">min_type</span><span class="p">,</span> <span class="n">max_type</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
            
        <span class="c1"># Add all pairs in the interval to the list of nested_subpairs</span>
        <span class="n">pairs_between</span><span class="p">[</span><span class="n">matched_pair</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">pair</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">matched_pairs</span> <span class="k">if</span> <span class="n">pair</span> <span class="o">!=</span> <span class="n">matched_pair</span> <span class="ow">and</span>
                    <span class="n">min_type</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="n">max_type</span> <span class="ow">and</span>
                    <span class="n">min_type</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="n">max_type</span><span class="p">}</span>
    
    <span class="n">subpairs</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">pairs_between</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="c1"># Remove nested pairs</span>
    <span class="k">for</span> <span class="n">matched_pair</span> <span class="ow">in</span> <span class="n">matched_pairs</span> <span class="o">|</span> <span class="p">{</span><span class="s1">&#39;artificial_pair&#39;</span><span class="p">}:</span>
        <span class="c1"># Compute all nested subpairs </span>
        <span class="n">nested_subpairs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">subpairs</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span> 
                                <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">subpairs</span><span class="p">[</span><span class="n">matched_pair</span><span class="p">]))</span> 
        <span class="c1"># Remove nested pairs from subpairs[matched_pair]</span>
        <span class="n">subpairs</span><span class="p">[</span><span class="n">matched_pair</span><span class="p">]</span> <span class="o">-=</span> <span class="n">nested_subpairs</span>
        <span class="c1"># subpairs[matched_pair].discard(matched_pair)</span>
        <span class="n">subpairs</span><span class="p">[</span><span class="n">matched_pair</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">subpairs</span><span class="p">[</span><span class="n">matched_pair</span><span class="p">])</span>

        <span class="c1"># Order the subpairs: </span>
        <span class="c1"># the first (last) pair should have x (y) close to pair_x (pair_y)</span>
        <span class="k">if</span> <span class="n">matched_pair</span> <span class="o">!=</span> <span class="s1">&#39;artificial_pair&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">subpairs</span><span class="p">[</span><span class="n">matched_pair</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">subpairs</span><span class="p">[</span><span class="n">matched_pair</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_subpairs</span><span class="p">(</span>
                <span class="n">subpairs</span><span class="p">[</span><span class="n">matched_pair</span><span class="p">],</span> 
                <span class="n">x_smaller_y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">[</span><span class="n">matched_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> 
                            <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">[</span><span class="n">matched_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

    <span class="k">if</span> <span class="n">return_pairs_between</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">subpairs</span><span class="p">,</span> <span class="n">pairs_between</span>
    <span class="k">return</span> <span class="n">subpairs</span>

<span class="n">OffDiagonal</span><span class="o">.</span><span class="n">find_subpairs</span> <span class="o">=</span> <span class="n">find_subpairs</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">subpairs</span><span class="p">,</span> <span class="n">pairs_between</span> <span class="o">=</span> <span class="n">exam_assign_OD</span><span class="o">.</span><span class="n">find_subpairs</span><span class="p">(</span><span class="n">assignment</span><span class="p">,</span> 
                                                <span class="n">return_pairs_between</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">subpairs</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{(5, 5): [(4, 7), (1, 3)],
 &#39;artificial_pair&#39;: [(5, 5), (2, 6)],
 (3, 1): [(7, 0), (0, 2)],
 (7, 0): [],
 (6, 4): [],
 (0, 2): [],
 (2, 6): [],
 (1, 3): [],
 (4, 7): [(6, 4), (3, 1)]}
</pre></div>
</div>
</div>
</div>
<p>The algorithm to compute the dual variables has a hierarchical structure: it starts from the matched pairs with no subpairs and then moves to those pairs whose subpairs have been already processed.</p>
<p>We can visualize the hierarchical structure by computing the order in which he pairs will be processed and plotting the matching with color of the arcs corresponding the hierarchy.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Compute Hierarchies</span>

<span class="k">def</span> <span class="nf">find_hierarchies</span><span class="p">(</span><span class="n">subpairs</span><span class="p">):</span>  
    
    <span class="c1"># Initialize sets for faster membership checks</span>
    <span class="n">pairs_to_process</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">subpairs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>  <span class="c1"># All pairs to process</span>
    <span class="n">processed_pairs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># Pairs that have been processed</span>

    <span class="c1"># Initialize ready_to_process with pairs that have no subpairs</span>
    <span class="n">ready_to_process</span> <span class="o">=</span> <span class="p">{</span><span class="n">pair</span> <span class="k">for</span> <span class="n">pair</span><span class="p">,</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">subpairs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">}</span>

    <span class="c1"># Initialize hierarchies with the first level</span>
    <span class="n">hierarchies</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ready_to_process</span><span class="p">)]</span>

    <span class="c1"># Continue processing while there are unprocessed pairs</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">processed_pairs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">subpairs</span><span class="p">):</span>
        <span class="c1"># Mark ready_to_process pairs as processed</span>
        <span class="n">processed_pairs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ready_to_process</span><span class="p">)</span>

        <span class="c1"># Remove ready_to_process pairs from pairs_to_process</span>
        <span class="n">pairs_to_process</span> <span class="o">-=</span> <span class="n">ready_to_process</span>

        <span class="c1"># Find new ready_to_process pairs that have all their subpairs processed</span>
        <span class="n">ready_to_process</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">pair</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairs_to_process</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">subpair</span> <span class="ow">in</span> <span class="n">processed_pairs</span> <span class="k">for</span> <span class="n">subpair</span> <span class="ow">in</span> <span class="n">subpairs</span><span class="p">[</span><span class="n">pair</span><span class="p">])}</span>

        <span class="c1"># Append the new ready_to_process to hierarchies</span>
        <span class="n">hierarchies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ready_to_process</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">hierarchies</span>

<span class="c1">## Plot Hierarchies</span>

<span class="k">def</span> <span class="nf">plot_hierarchies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subpairs</span><span class="p">,</span> <span class="n">scatter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">range_x_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># Compute hierarchies</span>
    <span class="n">hierarchies</span> <span class="o">=</span> <span class="n">find_hierarchies</span><span class="p">(</span><span class="n">subpairs</span><span class="p">)</span>

    <span class="c1"># Create the figure and axis</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>

    <span class="c1"># Plot types on the real line (blue for X_types, red for Y_types)</span>
    <span class="n">size_marker</span> <span class="o">=</span> <span class="mi">20</span> <span class="k">if</span> <span class="n">scatter</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> 
                    <span class="n">s</span><span class="o">=</span><span class="n">size_marker</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;X_types&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> 
                    <span class="n">s</span><span class="o">=</span><span class="n">size_marker</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Y_types&#39;</span><span class="p">)</span>

    <span class="c1"># Plot arcs</span>
    <span class="c1"># Create a colormap (&#39;viridis&#39; or &#39;coolwarm&#39;, &#39;plasma&#39;)</span>
    <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colormaps</span><span class="p">[</span><span class="s1">&#39;plasma&#39;</span><span class="p">]</span> 
    <span class="k">for</span> <span class="n">level</span><span class="p">,</span> <span class="n">hierarchy</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hierarchies</span><span class="p">):</span>
        <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="n">cmap</span><span class="p">(</span><span class="n">level</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hierarchies</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> 
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hierarchies</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">cmap</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">hierarchy</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pair</span> <span class="o">==</span> <span class="s1">&#39;artificial_pair&#39;</span><span class="p">:</span>
                <span class="k">continue</span>  

            <span class="n">min_type</span><span class="p">,</span> <span class="n">max_type</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> 
                                         <span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>
            <span class="n">width</span> <span class="o">=</span> <span class="n">max_type</span> <span class="o">-</span> <span class="n">min_type</span>
            <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_type</span> <span class="o">+</span> <span class="n">min_type</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="c1"># Semicircle height can be the same as the width for a perfect arc</span>
            <span class="n">height</span> <span class="o">=</span> <span class="n">width</span>  
            <span class="n">semicircle</span> <span class="o">=</span> <span class="n">patches</span><span class="o">.</span><span class="n">Arc</span><span class="p">((</span><span class="n">center</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> 
                            <span class="n">theta1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta2</span><span class="o">=</span><span class="mi">180</span><span class="p">,</span> 
                            <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">lw</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">semicircle</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">range_x_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">range_x_axis</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="o">.</span><span class="n">ptp</span><span class="p">()</span> <span class="o">/</span> <span class="mi">10</span><span class="p">,</span> 
                    <span class="p">(</span><span class="n">range_x_axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">range_x_axis</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">)</span>

    <span class="c1"># Title and layout settings for the main plot</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Hierarchies of the optimal matching (off-diagonal)&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">((</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>  <span class="c1"># Hide the y-axis ticks</span>

    <span class="c1"># Add a colorbar to represent hierarchy levels</span>
    <span class="n">sm</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> 
                    <span class="n">norm</span><span class="o">=</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hierarchies</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">sm</span><span class="o">.</span><span class="n">set_array</span><span class="p">([])</span>
    <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;vertical&#39;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>   
    <span class="c1"># Show only min and max levels </span>
    <span class="n">cbar</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">hierarchies</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
    <span class="c1"># Label the ticks for clarity</span>
    <span class="n">cbar</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">([</span><span class="s1">&#39;Lowest&#39;</span><span class="p">,</span> <span class="s1">&#39;Highest&#39;</span><span class="p">])</span> 

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">OffDiagonal</span><span class="o">.</span><span class="n">plot_hierarchies</span> <span class="o">=</span> <span class="n">plot_hierarchies</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">exam_assign_OD</span><span class="o">.</span><span class="n">plot_hierarchies</span><span class="p">(</span><span class="n">subpairs</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/2dd40c6110ada9f6645dbf4e3406f0a8df601e58182af423bdd8248cc2efc6c1.png" src="_images/2dd40c6110ada9f6645dbf4e3406f0a8df601e58182af423bdd8248cc2efc6c1.png" />
</div>
</div>
<p>We proceed to describe and implement the algorithm to compute the dual solution.</p>
<p>As already mentioned, the algorithm starts from the matched pairs <span class="math notranslate nohighlight">\((x_0,y_0)\)</span> with no subpairs and assigns the (temporary) values <span class="math notranslate nohighlight">\(\psi_{x_0} = c_{x_0 y_0}\)</span> and <span class="math notranslate nohighlight">\(\psi_{y_0} = 0,\)</span> i.e. the <span class="math notranslate nohighlight">\(x\)</span> type sustains the whole cost of matching.</p>
<p>The algorithm then proceeds sequentially  by processing any matched pair whose subpairs have already been processed.</p>
<p>After picking any such matched pair <span class="math notranslate nohighlight">\((x_0,y_0)\)</span>, the dual variables already computed for the processed subpairs need to be made “comparable”.</p>
<p>Indeed, for any subpair <span class="math notranslate nohighlight">\((x_1,y_1)\)</span> of <span class="math notranslate nohighlight">\((x_0,y_0)\)</span>, the dual variables of all the types between the <span class="math notranslate nohighlight">\(x_1\)</span> and <span class="math notranslate nohighlight">\(y_1\)</span> satisfy dual feasibility and complementary slackness <em>locally</em>, i.e. <span class="math notranslate nohighlight">\(\phi_x + \psi_y \leq c_{xy}\)</span> with equality if <span class="math notranslate nohighlight">\((x,y)\)</span> is a matched pair for all types <span class="math notranslate nohighlight">\(x,y\)</span> between  <span class="math notranslate nohighlight">\(x_0\)</span> and <span class="math notranslate nohighlight">\(y_0.\)</span></p>
<p>But dual feasibility is not satisfied globally in general, for instance it might not be satisfied for two subpairs <span class="math notranslate nohighlight">\((x_1,y_1)\)</span> and  <span class="math notranslate nohighlight">\((x_2,y_2)\)</span> of <span class="math notranslate nohighlight">\((x_0,y_0).\)</span></p>
<p>Therefore, letting  <span class="math notranslate nohighlight">\((x_1,y_1), \dots,  (x_p,y_p)\)</span> be the subpairs of <span class="math notranslate nohighlight">\((x_0,y_0),\)</span> we compute the solution <span class="math notranslate nohighlight">\((\beta_2, \dots, \beta_p) \)</span> of the linear system</p>
<div class="math notranslate nohighlight">
\[
\max (c_{x_0 y_0} - c_{x_0 y_i} - c_{x_j y_0} , - c_{x_j y_i}) + c_{x_i y_i} 
\leq \sum_{k=i+1}^{j} \beta_k 
\leq \min (c_{x_0 y_j} + c_{x_i y_0} - c_{x_0 y_0} , c_{x_i y_j}) -  c_{x_j y_j} , \quad \text{for all } 1 \leq i &lt; j \leq p.
\]</div>
<p>Then for all <span class="math notranslate nohighlight">\(i \in [p]\)</span> compute the adjustment <span class="math notranslate nohighlight">\( \Delta_i = \sum_{k = i+1}^p \beta_k + \phi_{x_p} - \phi_{x_1}\)</span> and modify the dual variables</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\phi_{x} &amp;\leftarrow \phi_{x} + \Delta_i \\
\psi_{y} &amp;\leftarrow \psi_{y} - \Delta_i,
\end{aligned}
\end{split}\]</div>
<p>for all matched pairs <span class="math notranslate nohighlight">\((x,y)\)</span> between <span class="math notranslate nohighlight">\(x_i\)</span> and <span class="math notranslate nohighlight">\(y_i.\)</span></p>
<p>After this step, the dual variables of the types between <span class="math notranslate nohighlight">\(x_0\)</span> and <span class="math notranslate nohighlight">\(y_0\)</span> satisfy dual feasibility and complementary slackness; we can then proceed to compute the dual variables for <span class="math notranslate nohighlight">\(x_0\)</span> and <span class="math notranslate nohighlight">\(y_0\)</span> by setting</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
&amp;\psi_{y_0} = \min_{i \in [p]} \{ c_{x_i y_0} - \phi_{x_i} \} \\
&amp;\phi_{x_0} = c_{x_0 y_0}  - \psi_{y_0}.
\end{aligned}
\end{split}\]</div>
<p>The pair <span class="math notranslate nohighlight">\((x_0,y_0)\)</span> is now processed.</p>
<p>The following method computes the solution <span class="math notranslate nohighlight">\(\beta\)</span> of the linear system of inequalities above.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compute_betas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">subpairs</span><span class="p">):</span>
    <span class="n">types_subpairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">subpairs</span><span class="p">)</span>

    <span class="c1"># Define the bounds of the linear inequality system</span>
    <span class="k">if</span> <span class="n">pair</span> <span class="o">==</span> <span class="s1">&#39;artificial_pair&#39;</span><span class="p">:</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">[</span><span class="n">types_subpairs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][:,</span><span class="kc">None</span><span class="p">],</span> 
                <span class="n">types_subpairs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">][</span><span class="kc">None</span><span class="p">,:]]</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">[</span><span class="n">types_subpairs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> 
                                <span class="n">types_subpairs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]][</span><span class="kc">None</span><span class="p">,:])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span>  
        <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">types_subpairs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]][</span><span class="kc">None</span><span class="p">,:]</span> 
        <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">[</span><span class="n">types_subpairs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]][:,</span><span class="kc">None</span><span class="p">],</span>
        <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">[</span><span class="n">types_subpairs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">][:,</span><span class="kc">None</span><span class="p">],</span> 
        <span class="n">types_subpairs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">][</span><span class="kc">None</span><span class="p">,:]]</span>
        <span class="p">)</span>
        <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">[</span><span class="n">types_subpairs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">types_subpairs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]][</span><span class="kc">None</span><span class="p">,:])</span>
    
    <span class="c1"># Define linear inequality system </span>
    <span class="n">num_subpairs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">types_subpairs</span><span class="p">)</span>
    <span class="n">c_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_subpairs</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> 
            <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_subpairs</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
    <span class="n">c_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_subpairs</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> 
            <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_subpairs</span><span class="p">)[</span> <span class="kc">None</span><span class="p">,:,</span> <span class="kc">None</span><span class="p">])</span>
    <span class="n">sum_tensor</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_1</span> <span class="o">&amp;</span> <span class="n">c_2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">sum_tensor</span> <span class="o">-=</span> <span class="n">sum_tensor</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> 
    
    <span class="c1"># Solve the system of linear inequalities</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">linprog</span><span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_subpairs</span><span class="p">),</span> 
                    <span class="n">A_ub</span><span class="o">=</span> <span class="o">-</span> <span class="n">sum_tensor</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_subpairs</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_subpairs</span><span class="p">),</span> 
                    <span class="n">b_ub</span><span class="o">=</span> <span class="o">-</span> <span class="n">bounds</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> 
                    <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">),</span> 
                    <span class="n">method</span><span class="o">=</span><span class="s1">&#39;highs&#39;</span><span class="p">)</span>
    
    <span class="n">beta</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span>
    <span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> 

    <span class="k">return</span> <span class="n">beta</span>
    
<span class="n">OffDiagonal</span><span class="o">.</span><span class="n">compute_betas</span> <span class="o">=</span> <span class="n">compute_betas</span>
</pre></div>
</div>
</div>
</div>
<p>The following method iteratively processes the matched pairs of the off-diagonal matching as explained above.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compute_dual_off_diagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subpairs</span><span class="p">,</span> <span class="n">pairs_between</span><span class="p">):</span>

    <span class="c1"># Initialize dual variables</span>
    <span class="n">ϕ_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">))</span>
    <span class="n">ψ_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">))</span>

    <span class="c1"># Initialize sets for faster membership checks</span>
    <span class="n">pairs_to_process</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">subpairs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>  <span class="c1"># All pairs to process</span>
    <span class="n">processed_pairs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># Pairs that have been processed</span>

    <span class="c1"># Initialize ready_to_process with pairs that have no subpairs</span>
    <span class="n">ready_to_process</span> <span class="o">=</span> <span class="p">{</span><span class="n">pair</span> <span class="k">for</span> <span class="n">pair</span><span class="p">,</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">subpairs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">}</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">processed_pairs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">subpairs</span><span class="p">):</span> 
        
        <span class="c1"># 1. Pick any subpair which is ready to process </span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">ready_to_process</span><span class="p">:</span>

            <span class="c1"># 2. If there are no subpairs, φ_x = c_{xy} and ψ_y = 0</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subpairs</span><span class="p">[</span><span class="n">pair</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ϕ_x</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span>
                <span class="n">ψ_y</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># 3. If there are subpairs:</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># (a) compute betas</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_betas</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="n">subpairs</span><span class="p">[</span><span class="n">pair</span><span class="p">])</span>

                <span class="c1"># (b) adjust potentials of types between each subpair of the pair</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">subpair</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subpairs</span><span class="p">[</span><span class="n">pair</span><span class="p">]):</span>
                    <span class="c1"># update potentials of these types</span>
                    <span class="n">types_between_subpair</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                                <span class="nb">list</span><span class="p">(</span><span class="n">pairs_between</span><span class="p">[</span><span class="n">subpair</span><span class="p">])</span> <span class="o">+</span> <span class="p">[</span><span class="n">subpair</span><span class="p">])</span>

                    <span class="n">Δ_subpair</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">subpairs</span><span class="p">[</span><span class="n">pair</span><span class="p">]))]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> 
                                 <span class="o">+</span> <span class="n">ϕ_x</span><span class="p">[</span><span class="n">subpairs</span><span class="p">[</span><span class="n">pair</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> 
                                 <span class="o">-</span> <span class="n">ϕ_x</span><span class="p">[</span><span class="n">subpair</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
             
                    <span class="n">ϕ_x</span><span class="p">[</span> <span class="n">types_between_subpair</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">Δ_subpair</span>
                    <span class="n">ψ_y</span><span class="p">[</span> <span class="n">types_between_subpair</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-=</span> <span class="n">Δ_subpair</span>
      
                <span class="c1"># (c) compute potentials of the pair</span>
                <span class="n">subpairs_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">subpairs</span><span class="p">[</span><span class="n">pair</span><span class="p">])[:,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">subpairs_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">subpairs</span><span class="p">[</span><span class="n">pair</span><span class="p">])[:,</span><span class="mi">1</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="n">pair</span> <span class="o">!=</span> <span class="s1">&#39;artificial_pair&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">subpairs_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">ψ_y</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">subpairs_y</span><span class="p">]</span> 
                                    <span class="o">-</span> <span class="n">ψ_y</span><span class="p">[</span><span class="n">subpairs_y</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ψ_y</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">[</span><span class="n">subpairs_x</span><span class="p">,</span> 
                                         <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">ϕ_x</span><span class="p">[</span><span class="n">subpairs_x</span><span class="p">]</span> <span class="p">)</span>


                    <span class="n">ϕ_x</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span> <span class="o">-</span> <span class="n">ψ_y</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> 

            <span class="c1"># Add pair to processed pairs</span>
            <span class="n">processed_pairs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
      
        <span class="c1"># Remove ready_to_process from pairs_to_process</span>
        <span class="n">pairs_to_process</span> <span class="o">-=</span> <span class="n">ready_to_process</span>

        <span class="c1"># Add to ready_to_process pairs for which all subpairs are in processed_pairs</span>
        <span class="n">ready_to_process</span> <span class="o">=</span> <span class="p">{</span><span class="n">pair</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairs_to_process</span> 
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">subpair</span> <span class="ow">in</span> <span class="n">processed_pairs</span> <span class="k">for</span> <span class="n">subpair</span> <span class="ow">in</span> <span class="n">subpairs</span><span class="p">[</span><span class="n">pair</span><span class="p">])}</span>

    <span class="k">return</span> <span class="n">ϕ_x</span><span class="p">,</span> <span class="n">ψ_y</span>

<span class="n">OffDiagonal</span><span class="o">.</span><span class="n">compute_dual_off_diagonal</span> <span class="o">=</span> <span class="n">compute_dual_off_diagonal</span>
</pre></div>
</div>
</div>
</div>
<p>We apply the algorithm to our example and check that dual feasibility (<span class="math notranslate nohighlight">\(\phi_x + \psi_y \leq c_{xy}\)</span> for all <span class="math notranslate nohighlight">\(x \in X\)</span> and <span class="math notranslate nohighlight">\(y \in Y\)</span>) as well as strong duality (<span class="math notranslate nohighlight">\(V_P = V_D\)</span>) are satisfied.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ϕ_x</span> <span class="p">,</span> <span class="n">ψ_y</span> <span class="o">=</span> <span class="n">exam_assign_OD</span><span class="o">.</span><span class="n">compute_dual_off_diagonal</span><span class="p">(</span><span class="n">subpairs</span><span class="p">,</span> <span class="n">pairs_between</span><span class="p">)</span>

<span class="c1"># Check dual feasibility</span>
<span class="n">dual_feasibility_i_j</span> <span class="o">=</span> <span class="n">ϕ_x</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">ψ_y</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">exam_assign_OD</span><span class="o">.</span><span class="n">cost_x_y</span> 
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Violations of dual feasibility:&#39;</span> <span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dual_feasibility_i_j</span> <span class="o">&gt;</span> <span class="mf">1e-10</span><span class="p">))</span>

<span class="n">dual_sol</span> <span class="o">=</span> <span class="p">(</span><span class="n">exam_assign_OD</span><span class="o">.</span><span class="n">n_x</span> <span class="o">*</span> <span class="n">ϕ_x</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">exam_assign_OD</span><span class="o">.</span><span class="n">m_y</span><span class="o">*</span> <span class="n">ψ_y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="n">primal_sol</span> <span class="o">=</span> <span class="p">(</span><span class="n">assignment_OD</span> <span class="o">*</span> <span class="n">exam_assign_OD</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

<span class="c1"># Check strong duality</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Value of dual solution: &#39;</span><span class="p">,</span> <span class="n">dual_sol</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Value of primal solution: &#39;</span><span class="p">,</span> <span class="n">primal_sol</span><span class="p">)</span>

<span class="c1"># # Check the value of the primal problem</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">exam_assign_OD</span><span class="o">.</span><span class="n">n_x</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">exam_assign_OD</span><span class="o">.</span><span class="n">m_y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">:</span>
    <span class="n">mu_x_y</span> <span class="p">,</span> <span class="n">p_z</span><span class="o">=</span> <span class="n">solve_1to1</span><span class="p">(</span><span class="n">exam_assign_OD</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">,</span>
                            <span class="n">exam_assign_OD</span><span class="o">.</span><span class="n">n_x</span><span class="p">,</span>
                            <span class="n">exam_assign_OD</span><span class="o">.</span><span class="n">m_y</span><span class="p">,</span>
                            <span class="n">return_dual</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Value of primal solution (scipy)&#39;</span><span class="p">,</span> 
    <span class="p">(</span><span class="n">mu_x_y</span> <span class="o">*</span> <span class="n">exam_assign_OD</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Violations of dual feasibility: 0
Value of dual solution:  9.03369035213102
Value of primal solution:  9.03369035213102
Value of primal solution (scipy) 9.03369035213102
</pre></div>
</div>
</div>
</div>
<p>Having computed the dual variables of the off-diagonal types, we compute the dual variables for perfecly matched pairs by setting</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\phi_{x} = \min_{y \in Y^{OD}} \{ c_{xy} -\psi_{y} \} \\
\psi_{y} = \min_{x \in X^{OD}} \{ c_{xy} -\phi_{x} \}
\end{aligned}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(X^{OD}\)</span> and <span class="math notranslate nohighlight">\(Y^{OD}\)</span> are the types of the off-diagonal instance, for which the dual variables have already been computed.</p>
<p>The following method computes the full dual solution from the primal solution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compute_dual_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matching_off_diag</span><span class="p">):</span>

    <span class="c1"># Compute the dual solution for the off-diagonal types</span>
    <span class="n">off_diag</span><span class="p">,</span> <span class="n">match_tuple</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_offD_onD_matching</span><span class="p">()</span>
    <span class="n">nonzero_id_x</span><span class="p">,</span> <span class="n">nonzero_id_y</span><span class="p">,</span> <span class="n">matching_diag</span> <span class="o">=</span> <span class="n">match_tuple</span>

    <span class="n">subpairs</span><span class="p">,</span> <span class="n">pairs_between</span> <span class="o">=</span> <span class="n">off_diag</span><span class="o">.</span><span class="n">find_subpairs</span><span class="p">(</span><span class="n">matching_off_diag</span><span class="p">,</span> 
                                                <span class="n">return_pairs_between</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">ϕ_x_off_diag</span><span class="p">,</span> <span class="n">ψ_x_off_diag</span> <span class="o">=</span> <span class="n">off_diag</span><span class="o">.</span><span class="n">compute_dual_off_diagonal</span><span class="p">(</span>
                                        <span class="n">subpairs</span><span class="p">,</span><span class="n">pairs_between</span><span class="p">)</span>
    
    <span class="c1"># Compute the dual solution for the on-diagonal types</span>
    <span class="n">ϕ_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">ψ_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="n">ϕ_x</span><span class="p">[</span><span class="n">nonzero_id_x</span><span class="p">]</span> <span class="o">=</span> <span class="n">ϕ_x_off_diag</span>
    <span class="n">ψ_y</span><span class="p">[</span><span class="n">nonzero_id_y</span><span class="p">]</span> <span class="o">=</span> <span class="n">ψ_x_off_diag</span>
    
    <span class="n">ϕ_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_x_y</span> <span class="o">-</span> <span class="n">ψ_y</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span> <span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ψ_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_x_y</span> <span class="o">-</span> <span class="n">ϕ_x</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ϕ_x</span><span class="p">,</span> <span class="n">ψ_y</span>

<span class="n">ConcaveCostOT</span><span class="o">.</span><span class="n">compute_dual_solution</span> <span class="o">=</span> <span class="n">compute_dual_solution</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ϕ_x</span><span class="p">,</span> <span class="n">ψ_y</span> <span class="o">=</span> <span class="n">exam_assign</span><span class="o">.</span><span class="n">compute_dual_solution</span><span class="p">(</span><span class="n">assignment_OD</span><span class="p">)</span>

<span class="n">dual_feasibility_i_j</span> <span class="o">=</span> <span class="n">ϕ_x</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">ψ_y</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">exam_assign</span><span class="o">.</span><span class="n">cost_x_y</span> 
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Violations of dual feasibility:&#39;</span> <span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dual_feasibility_i_j</span> <span class="o">&gt;</span> <span class="mf">1e-10</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Value of dual solution: &#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">exam_assign</span><span class="o">.</span><span class="n">n_x</span> <span class="o">*</span> <span class="n">ϕ_x</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> 
                                <span class="o">+</span> <span class="p">(</span><span class="n">exam_assign</span><span class="o">.</span><span class="n">m_y</span> <span class="o">*</span> <span class="n">ψ_y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Value of primal solution: &#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">assignment</span> <span class="o">*</span> <span class="n">exam_assign</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Violations of dual feasibility: 0
Value of dual solution:  9.03369035213102
Value of primal solution:  9.03369035213102
</pre></div>
</div>
</div>
</div>
</section>
<section id="application">
<h2><span class="section-number">16.7. </span>Application<a class="headerlink" href="#application" title="Permalink to this heading">#</a></h2>
<section id="data">
<h3><span class="section-number">16.7.1. </span>Data<a class="headerlink" href="#data" title="Permalink to this heading">#</a></h3>
<p>We now replicate the empirical analysis carried out by <span id="id10">[<a class="reference internal" href="zreferences.html#id3" title="Job Boerma, Aleh Tsyvinski, Ruodu Wang, and Zhenyuan Zhang. Composite sorting. Technical Report, University of Wisconsin, 2024.">Boerma <em>et al.</em>, 2024</a>]</span>.</p>
<p>The dataset is obtained from the American Community Survey and contains individual level data on income, age and occupation.</p>
<p>The occupation of each individual consists of a Standard Occupational Classification (SOC) code.</p>
<p>There are 497 codes in total.</p>
<p>We consider only employed (civilian) individuals with ages between 25 and 60 from 2010 to 2017.</p>
<p>To visualize log-wage dispersion, we group the individuals by occupation and compute the mean and standard deviation of the wages within each occupation.</p>
<p>Then we sort  occupations by average log-earnings within each occupation.</p>
<p>The resulting dataset is included in the dataset <code class="docutils literal notranslate"><span class="pre">acs_data_summary.csv</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">data_path</span> <span class="o">=</span> <span class="s1">&#39;_static/lecture_specific/match_transport/&#39;</span>
<span class="n">occupation_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">data_path</span> <span class="o">+</span> <span class="s1">&#39;acs_data_summary.csv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We plot the wage standard deviation for the sorted occupations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Scatter plot wage dispersion for each occupation</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="c1"># Scatter plot with marker size proportional to count</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
    <span class="n">occupation_df</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
    <span class="n">occupation_df</span><span class="p">[</span><span class="s1">&#39;std_Earnings&#39;</span><span class="p">],</span>
    <span class="c1"># marker_sizes</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="p">(</span><span class="n">occupation_df</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">occupation_df</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span> 
    <span class="c1"># transparency</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> 
    <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;Occupations&#39;</span>
<span class="p">)</span>

<span class="c1"># Polynomial interpolation</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">occupation_df</span><span class="p">))</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">occupation_df</span><span class="p">[</span><span class="s1">&#39;std_Earnings&#39;</span><span class="p">]</span>
<span class="n">degree</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>  <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>

<span class="c1"># Add labels and title</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Occupations&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Wage Dispersion&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<figure class="align-default" id="id11">
<img alt="_images/138fa8c86135daed058ae556cb6c69b9780dccc6dae62ecdf38b087acf83cbd0.png" src="_images/138fa8c86135daed058ae556cb6c69b9780dccc6dae62ecdf38b087acf83cbd0.png" />
<figcaption>
<p><span class="caption-number">Fig. 16.1 </span><span class="caption-text">Average wage for each Standard Occupational Classification (SOC) code. The codes are sorted by average wage on the horizontal axis. In red, a polynomial of degree 5 is fitted to the data. The size of the marker is proportional to the number of individuals in the occupation.</span><a class="headerlink" href="#id11" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</div>
</div>
<p>We also plot the average wages for each occupation (SOC code). Again, occupations are ordered by increasing average wage.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Scatter plot average wage for each occupation</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="c1"># Scatter plot with marker size proportional to count</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
    <span class="n">occupation_df</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
    <span class="n">occupation_df</span><span class="p">[</span><span class="s1">&#39;mean_Earnings&#39;</span><span class="p">],</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="c1"># transparency</span>
    <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;Occupations&#39;</span>
<span class="p">)</span>

<span class="c1"># Polynomial interpolation</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">occupation_df</span><span class="p">))</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">occupation_df</span><span class="p">[</span><span class="s1">&#39;mean_Earnings&#39;</span><span class="p">]</span>
<span class="n">degree</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>  <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>

<span class="c1"># Add labels and title</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Occupations&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Average Wage&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<figure class="align-default" id="id12">
<img alt="_images/ca4abb66441ba706f4ce30c50442f91e4eda1befc656e52a2c7f12a8db02785a.png" src="_images/ca4abb66441ba706f4ce30c50442f91e4eda1befc656e52a2c7f12a8db02785a.png" />
<figcaption>
<p><span class="caption-number">Fig. 16.2 </span><span class="caption-text">Average wage for each Standard Occupational Classification (SOC) code. The codes are sorted by average wage on the horizontal axis. In red, a polynomial of degree 5 is fitted to the data.</span><a class="headerlink" href="#id12" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</div>
</div>
</section>
<section id="model">
<h3><span class="section-number">16.7.2. </span>Model<a class="headerlink" href="#model" title="Permalink to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">parameters_1980</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Params_Jobs&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="s1">&#39;mean_1&#39;</span><span class="p">,</span> <span class="s1">&#39;var_1&#39;</span><span class="p">,</span> <span class="s1">&#39;mean_2&#39;</span><span class="p">,</span> <span class="s1">&#39;var_2&#39;</span><span class="p">,</span> <span class="s1">&#39;mixing_weight&#39;</span><span class="p">,</span> <span class="s1">&#39;var_workers&#39;</span>
<span class="p">])(</span>
    <span class="n">mean_1</span><span class="o">=</span><span class="mf">0.38</span><span class="p">,</span>
    <span class="n">var_1</span><span class="o">=</span><span class="mf">0.06</span><span class="p">,</span>
    <span class="n">mean_2</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="n">var_2</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span>
    <span class="n">mixing_weight</span><span class="o">=</span><span class="mf">0.36</span><span class="p">,</span>
    <span class="n">var_workers</span><span class="o">=</span><span class="mf">0.2</span>
<span class="p">)</span>

<span class="n">num_agents</span><span class="o">=</span><span class="mi">1500</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_types_application</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_agents</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

    <span class="n">mean_1</span><span class="p">,</span> <span class="n">var_1</span><span class="p">,</span> <span class="n">mean_2</span><span class="p">,</span> <span class="n">var_2</span><span class="p">,</span> <span class="n">mixing_weight</span><span class="p">,</span> <span class="n">var_workers</span> <span class="o">=</span> <span class="n">params</span>

    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>

    <span class="c1"># Job types</span>
    <span class="n">job_types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">num_agents</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">mixing_weight</span><span class="p">,</span> 
                     <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">lognormal</span><span class="p">(</span><span class="n">mean_1</span><span class="p">,</span> <span class="n">var_1</span><span class="p">,</span> <span class="n">num_agents</span><span class="p">),</span> 
                     <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">lognormal</span><span class="p">(</span><span class="n">mean_2</span><span class="p">,</span> <span class="n">var_2</span><span class="p">,</span> <span class="n">num_agents</span><span class="p">))</span>

    <span class="c1"># Worker types</span>
    <span class="n">mean_workers</span> <span class="o">=</span> <span class="o">-</span> <span class="n">var_workers</span><span class="o">/</span> <span class="mi">2</span>
    <span class="n">worker_types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">lognormal</span><span class="p">(</span><span class="n">mean_workers</span><span class="p">,</span> <span class="n">var_workers</span><span class="p">,</span> <span class="n">num_agents</span><span class="p">)</span>

    <span class="c1"># Check that worker and job types have distinct values</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">worker_types</span><span class="p">))</span> <span class="o">==</span> <span class="n">num_agents</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">job_types</span><span class="p">))</span> <span class="o">==</span> <span class="n">num_agents</span>

    <span class="c1"># Assign types to the instance</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">X_types</span> <span class="o">=</span> <span class="n">worker_types</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span> <span class="o">=</span> <span class="n">job_types</span>

    <span class="c1"># Assign unitary marginals</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">n_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_agents</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">m_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_agents</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Assign cost matrix</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cost_x_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">worker_types</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> \
                    <span class="o">-</span> <span class="n">job_types</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">ζ</span><span class="p">)</span>

<span class="n">ConcaveCostOT</span><span class="o">.</span><span class="n">generate_types_application</span> <span class="o">=</span> <span class="n">generate_types_application</span>

<span class="c1"># Create an instance of ConcaveCostOT class and generate types</span>
<span class="n">model_1980</span> <span class="o">=</span> <span class="n">ConcaveCostOT</span><span class="p">()</span>
<span class="n">model_1980</span><span class="o">.</span><span class="n">generate_types_application</span><span class="p">(</span><span class="n">num_agents</span><span class="p">,</span> <span class="n">parameters_1980</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Since we will consider examples with a large number of agents, it will be convenient to visualize the distributions as histograms approximating the pdfs.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_marginals_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> 
                        <span class="n">range_x_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Distributions of types&#39;</span><span class="p">):</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>

    <span class="c1"># Plotting histogram for X_types (approximating PDF)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_types</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> 
             <span class="n">label</span><span class="o">=</span><span class="s1">&#39;PDF of worker types&#39;</span><span class="p">,</span> 
             <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="nb">range</span> <span class="o">=</span> <span class="n">range_x_axis</span><span class="p">)</span>

    <span class="c1"># Plotting histogram for Y_types (approximating PDF)</span>
    <span class="n">counts</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_types</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> 
                                <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">range_x_axis</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">counts</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">edges</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> 
            <span class="n">label</span><span class="o">=</span><span class="s1">&#39;PDF of job types &#39;</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>

    <span class="c1"># Add grid and y=0 axis</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">((</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c1"># Set the x-axis limits based on the range argument</span>
    <span class="k">if</span> <span class="n">range_x_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">range_x_axis</span><span class="p">)</span>

    <span class="c1"># Labeling the axes and the title</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Density&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">([])</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">ConcaveCostOT</span><span class="o">.</span><span class="n">plot_marginals_pdf</span> <span class="o">=</span> <span class="n">plot_marginals_pdf</span>
</pre></div>
</div>
</div>
</div>
<p>We plot the hystograms and the measure of underqualification for the worker types and job types. We then compute the primal solution and plot the matching.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot pdf</span>
<span class="n">range_x_axis</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">model_1980</span><span class="o">.</span><span class="n">plot_marginals_pdf</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> 
                              <span class="n">bins</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">range_x_axis</span><span class="o">=</span><span class="n">range_x_axis</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/59f58eb373632725c1607f64950edec7972413b16d674d836942fdd41e9defb1.png" src="_images/59f58eb373632725c1607f64950edec7972413b16d674d836942fdd41e9defb1.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot H_z</span>
<span class="n">model_OD_1980</span> <span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">model_1980</span><span class="o">.</span><span class="n">generate_offD_onD_matching</span><span class="p">()</span>
<span class="n">model_OD_1980</span><span class="o">.</span><span class="n">plot_H_z</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">range_x_axis</span><span class="o">=</span><span class="n">range_x_axis</span><span class="p">,</span> <span class="n">scatter</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/79a4b4e2ff6257864370bde1819c87de24eb7692f1d119e8a8c15ceac591541a.png" src="_images/79a4b4e2ff6257864370bde1819c87de24eb7692f1d119e8a8c15ceac591541a.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute optimal matching and plot off diagonal matching</span>
<span class="n">matching_1980</span><span class="p">,</span> <span class="n">matching_OD_1980</span><span class="p">,</span> <span class="n">model_OD_1980</span> <span class="o">=</span> <span class="n">model_1980</span><span class="o">.</span><span class="n">solve_primal_DSS</span><span class="p">()</span>
<span class="n">model_OD_1980</span><span class="o">.</span><span class="n">plot_matching</span><span class="p">(</span><span class="n">matching_OD_1980</span><span class="p">,</span> 
                            <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Optimal Matching (off-diagonal)&#39;</span><span class="p">,</span> 
                            <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">plot_H_z</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scatter</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/c7e4fea982375eea52e81a73a5c62d31a150442d5a6db372b3e31244d155f725.png" src="_images/c7e4fea982375eea52e81a73a5c62d31a150442d5a6db372b3e31244d155f725.png" />
</div>
</div>
<p>From the optimal matching we compute and visualize the hierarchies.</p>
<p>We then find the dual solution <span class="math notranslate nohighlight">\((\phi,\psi)\)</span> and compute the wages as <span class="math notranslate nohighlight">\(w_x = g(x) - \phi_x,\)</span> assuming that the type-specific productivity of type <span class="math notranslate nohighlight">\(x\)</span> is <span class="math notranslate nohighlight">\(g(x) = x\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Find subpairs and plot hierarchies</span>
<span class="n">subpairs</span><span class="p">,</span> <span class="n">pairs_between</span> <span class="o">=</span> <span class="n">model_OD_1980</span><span class="o">.</span><span class="n">find_subpairs</span><span class="p">(</span><span class="n">matching_OD_1980</span><span class="p">,</span> 
                                        <span class="n">return_pairs_between</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">model_OD_1980</span><span class="o">.</span><span class="n">plot_hierarchies</span><span class="p">(</span><span class="n">subpairs</span><span class="p">,</span> <span class="n">scatter</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                                        <span class="n">range_x_axis</span><span class="o">=</span><span class="n">range_x_axis</span><span class="p">)</span>

<span class="c1"># Compute dual solution: φ_x and ψ_y</span>
<span class="n">ϕ_worker_x_1980</span> <span class="p">,</span> <span class="n">ψ_firm_y_1980</span> <span class="o">=</span> <span class="n">model_OD_1980</span><span class="o">.</span><span class="n">compute_dual_off_diagonal</span><span class="p">(</span>
                                        <span class="n">subpairs</span><span class="p">,</span> <span class="n">pairs_between</span><span class="p">)</span>

<span class="c1"># Check dual feasibility</span>
<span class="n">dual_feasibility_i_j</span> <span class="o">=</span> <span class="n">ϕ_worker_x_1980</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">ψ_firm_y_1980</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span> \
                       <span class="o">-</span> <span class="n">model_OD_1980</span><span class="o">.</span><span class="n">cost_x_y</span> 
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dual feasibility violation:&#39;</span><span class="p">,</span> <span class="n">dual_feasibility_i_j</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

<span class="c1"># Check strong duality</span>
<span class="n">dual_sol</span> <span class="o">=</span> <span class="p">(</span><span class="n">model_OD_1980</span><span class="o">.</span><span class="n">n_x</span> <span class="o">*</span> <span class="n">ϕ_worker_x_1980</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> \
            <span class="o">+</span> <span class="p">(</span><span class="n">model_OD_1980</span><span class="o">.</span><span class="n">m_y</span> <span class="o">*</span> <span class="n">ψ_firm_y_1980</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="n">primal_sol</span> <span class="o">=</span> <span class="p">(</span><span class="n">matching_OD_1980</span> <span class="o">*</span> <span class="n">model_OD_1980</span><span class="o">.</span><span class="n">cost_x_y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Value of dual solution: &#39;</span><span class="p">,</span> <span class="n">dual_sol</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Value of primal solution: &#39;</span><span class="p">,</span> <span class="n">primal_sol</span><span class="p">)</span>

<span class="c1"># Compute wages: wage_x = x - φ_x </span>
<span class="n">wage_worker_x_1980</span> <span class="o">=</span> <span class="n">model_1980</span><span class="o">.</span><span class="n">X_types</span> <span class="o">-</span> <span class="n">ϕ_worker_x_1980</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/31aaf6fa9cb4becb4fc973594dd0ac0dd4178c6fc7b5361e4ba35218d09d2679.png" src="_images/31aaf6fa9cb4becb4fc973594dd0ac0dd4178c6fc7b5361e4ba35218d09d2679.png" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Dual feasibility violation: 4.322138159526534e-08
Value of dual solution:  825.8167029184153
Value of primal solution:  825.8167029184157
</pre></div>
</div>
</div>
</div>
<p>Let’s plot  average wages and wage dispersion generated by the model.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_wages_application</span><span class="p">(</span><span class="n">wages</span><span class="p">):</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">wages</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Wages&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Occupations&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Wages&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">plot_wage_dispersion_model</span><span class="p">(</span><span class="n">wage_worker_x</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
                                <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Wage Dispersion&#39;</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">)):</span>
    <span class="c1"># Compute the percentiles </span>
    <span class="n">percentiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">wage_worker_x</span><span class="p">,</span> <span class="n">percentiles</span><span class="p">)</span>
    
    <span class="c1"># Compute the standard deviation within each percentile range</span>
    <span class="n">stds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span>
        <span class="c1"># Compute the standard deviation for the current bin </span>
        <span class="n">bin_data</span> <span class="o">=</span> <span class="n">wage_worker_x</span><span class="p">[</span>
        <span class="p">(</span><span class="n">wage_worker_x</span> <span class="o">&gt;=</span> <span class="n">bin_edges</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">wage_worker_x</span> <span class="o">&lt;</span> <span class="n">bin_edges</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">stds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">bin_data</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c1"># Plot the standard deviations for each percentile as bars</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">bins</span><span class="p">),</span> <span class="n">stds</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">,</span> 
                            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Percentile&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Standard Deviation&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>
    

<span class="n">plot_wages_application</span><span class="p">(</span><span class="n">wage_worker_x_1980</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/b2575ce01ad3b3d2f658188ca29e0d9ddc78b8c26c612966b894a432dbaf7ee8.png" src="_images/b2575ce01ad3b3d2f658188ca29e0d9ddc78b8c26c612966b894a432dbaf7ee8.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plot_wage_dispersion_model</span><span class="p">(</span><span class="n">wage_worker_x_1980</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/45517133f05de0be7e2c7913339e19cce0ece1f876bacda05911b3396e3279e8.png" src="_images/45517133f05de0be7e2c7913339e19cce0ece1f876bacda05911b3396e3279e8.png" />
</div>
</div>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                    </div>
                    
                </main> <!-- .page__content -->
                


                <footer class="qe-page__footer">

                    <p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://licensebuttons.net/l/by-sa/4.0/80x15.png"></a></p>

                    <p>Creative Commons License &ndash; This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International.</p>

                </footer> <!-- .page__footer -->

            </div> <!-- .page -->

            

            
            <div class="qe-sidebar bd-sidebar inactive" id="site-navigation">

                <div class="qe-sidebar__header">


                    Contents

                </div>

                <nav class="qe-sidebar__nav" id="qe-sidebar-nav" aria-label="Main navigation">
                    <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Tools and Techniques
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="orth_proj.html">
   1. Orthogonal Projections and Their Applications
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="stationary_densities.html">
   2. Continuous State Markov Chains
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="muth_kalman.html">
   3. Reverse Engineering a la Muth
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="discrete_dp.html">
   4. Discrete State Dynamic Programming
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  LQ Control
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="cons_news.html">
   5. Information and Consumption Smoothing
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="smoothing.html">
   6. Consumption Smoothing with Complete and Incomplete Markets
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="smoothing_tax.html">
   7. Tax Smoothing with Complete and Incomplete Markets
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="markov_jump_lq.html">
   8. Markov Jump Linear Quadratic Dynamic Programming
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="tax_smoothing_1.html">
   9. How to Pay for a War: Part 1
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="tax_smoothing_2.html">
   10. How to Pay for a War: Part 2
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="tax_smoothing_3.html">
   11. How to Pay for a War: Part 3
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lqramsey.html">
   12. Optimal Taxation in an LQ Economy
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Multiple Agent Models
 </span>
</p>
<ul class="current nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="arellano.html">
   13. Default Risk and Income Fluctuations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="matsuyama.html">
   14. Globalization and Cycles
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="coase.html">
   15. Coase’s Theory of the Firm
  </a>
 </li>
 <li class="toctree-l1 current active active">
  <a class="current reference internal" href="#">
   16. Composite Sorting
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Dynamic Linear Economies
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="hs_recursive_models.html">
   17. Recursive Models of Dynamic Linear Economies
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="growth_in_dles.html">
   18. Growth in Dynamic Linear Economies
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lucas_asset_pricing_dles.html">
   19. Lucas Asset Pricing Using DLE
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="irfs_in_hall_model.html">
   20. IRFs in Hall Models
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="permanent_income_dles.html">
   21. Permanent Income Model using the DLE Class
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="rosen_schooling_model.html">
   22. Rosen Schooling Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cattle_cycles.html">
   23. Cattle Cycles
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="hs_invertibility_example.html">
   24. Shock Non Invertibility
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Risk, Model Uncertainty, and Robustness
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="five_preferences.html">
   25. Risk and Model Uncertainty
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="entropy.html">
   26. Etymology of Entropy
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="robustness.html">
   27. Robustness
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="rob_markov_perf.html">
   28. Robust Markov Perfect Equilibrium
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Time Series Models
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="arma.html">
   29. Covariance Stationary Processes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="estspec.html">
   30. Estimation of Spectra
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="additive_functionals.html">
   31. Additive and Multiplicative Functionals
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lu_tricks.html">
   32. Classical Control with Linear Algebra
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="classical_filtering.html">
   33. Classical Prediction and Filtering With Linear Algebra
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="knowing_forecasts_of_others.html">
   34. Knowing the Forecasts of Others
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Asset Pricing and Finance
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="lucas_model.html">
   35. Asset Pricing II: The Lucas Asset Pricing Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="asset_pricing_lph.html">
   36. Elementary Asset Pricing Theory
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="black_litterman.html">
   37. Two Modifications of Mean-Variance Portfolio Theory
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="BCG_complete_mkts.html">
   38. Irrelevance of Capital Structures with Complete Markets
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="BCG_incomplete_mkts.html">
   39. Equilibrium Capital Structures with Incomplete Markets
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Dynamic Programming Squared
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="un_insure.html">
   40. Optimal Unemployment Insurance
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="dyn_stack.html">
   41. Stackelberg Plans
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="calvo_machine_learn.html">
   42. Machine Learning a Ramsey Plan
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="calvo.html">
   43. Time Inconsistency of Ramsey Plans
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="calvo_abreu.html">
   44. Sustainable Plans for a Calvo Model
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="opt_tax_recur.html">
   45. Optimal Taxation with State-Contingent Debt
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="amss.html">
   46. Optimal Taxation without State-Contingent Debt
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="amss2.html">
   47. Fluctuating Interest Rates Deliver Fiscal Insurance
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="amss3.html">
   48. Fiscal Risk and Government Debt
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="chang_ramsey.html">
   49. Competitive Equilibria of a Model of Chang
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="chang_credible.html">
   50. Credible Government Policies in a Model of Chang
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Other
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="troubleshooting.html">
   51. Troubleshooting
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="zreferences.html">
   52. References
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="status.html">
   53. Execution Statistics
  </a>
 </li>
</ul>

                </nav>

                <div class="qe-sidebar__footer">

                </div>

            </div> <!-- .sidebar -->
            
        </div> <!-- .main -->

        <div class="qe-toolbar">

            <div class="qe-toolbar__inner">

                <ul class="qe-toolbar__main">
                    <li data-tippy-content="Table of Contents" class="btn__sidebar"><i data-feather="menu"></i></li>
                    <li data-tippy-content="Home"><a href="intro.html"><i data-feather="home"></i></a></li>
                    <li class="btn__qelogo"><a href="https://quantecon.org" title=""><span class="show-for-sr">QuantEcon</span></a></li>
                </ul>

                <ul class="qe-toolbar__links">
                    <li class="btn__search">
                        <form action="search.html" method="get">
                            <input type="search" class="form-control" name="q" id="search-input" placeholder="Search..." aria-label="Search..." autocomplete="off" accesskey="k">
                            <i data-feather="search" id="search-icon"></i>
                        </form>
                    </li>
                    <li data-tippy-content="Fullscreen" class="btn__fullscreen"><i data-feather="maximize"></i></li>
                    <li data-tippy-content="Increase font size" class="btn__plus"><i data-feather="plus-circle"></i></li>
                    <li data-tippy-content="Decrease font size" class="btn__minus"><i data-feather="minus-circle"></i></li>
                    <li data-tippy-content="Change contrast" class="btn__contrast"><i data-feather="sunset"></i></li>
                    <li data-tippy-content="Download Notebook"><a href="/_notebooks/match_transport.ipynb" download><i data-feather="download-cloud"></i></a></li>
                    <li class="settings-button" id="settingsButton"><div data-tippy-content="Launch Notebook"><i data-feather="play-circle"></i></div></li>
                        <li class="download-pdf" id="downloadButton"><i data-feather="file"></i></li>
                    <!--
                    # Enable if looking for link to specific document hosted on GitHub
                    <li data-tippy-content="View Source"><a target="_blank" href="https://github.com/QuantEcon/lecture-python-advanced.myst/blob/main/lectures/match_transport.md" download><i data-feather="github"></i></a></li>
                    -->
                    <li data-tippy-content="View Source"><a target="_blank" href="https://github.com/QuantEcon/lecture-python-advanced.myst" download><i data-feather="github"></i></a></li>
                </ul>

            </div>

        </div> <!-- .toolbar -->
        <div id="downloadPDFModal" style="display: none;">
            <ul class="pdf-options" style="display: block;">
                <li class="download-pdf-book" onClick="window.print()">
                    <p>Lecture (PDF)</p>
                </li>
                <li class="download-pdf-file">
                    <a href="/_pdf/quantecon-python-advanced.pdf" download><p>Book (PDF)</p></a>
                </li>
            </ul>
        </div>
        <div id="settingsModal" style="display: none;">
            <p class="modal-title"> Notebook Launcher </p>
            <div class="modal-desc">
            <p>
                Choose public or private cloud service for "Launch" button.
            </p>
            </div>
            <p class="modal-subtitle">Select a server</p>
            <ul class="modal-servers">
            <li class="active launcher-public">
                <span class="label">Public</span>
                <select id="launcher-public-input">
                
                    <option value="https://colab.research.google.com/github/QuantEcon/lecture-python-advanced.notebooks/blob/main/match_transport.ipynb">Colab</option>
                
                </select>
                <i class="fas fa-check-circle"></i>
            </li>
            <li class="launcher-private">
                <span class="label">Private</span>
                <input type="text" id="launcher-private-input" data-repourl="https://github.com/QuantEcon/lecture-python-advanced.notebooks" data-urlpath="tree/lecture-python-advanced.notebooks/match_transport.ipynb" data-branch=main>
                <i class="fas fa-check-circle"></i>
            </li>
            </ul>
            <p class="launch"><a href="https://colab.research.google.com/github/QuantEcon/lecture-python-advanced.notebooks/blob/main/match_transport.ipynb" id="advancedLaunchButton" target="_blank">Launch Notebook</a></p>
            <script>
                // QuantEcon Notebook Launcher
                const launcherTypeElements = document.querySelectorAll('#settingsModal .modal-servers li');
                // Highlight the server type if previous selection exists
                if (typeof localStorage.launcherType !== 'undefined') {
                  for (var i = 0; i < launcherTypeElements.length; i++) {
                    launcherTypeElements[i].classList.remove('active');
                    if ( launcherTypeElements[i].classList.contains(localStorage.launcherType) ) {
                      launcherTypeElements[i].classList.add('active');
                    }
                  }
                }
                // Highlight server type on click and set local storage value
                for (var i = 0; i < launcherTypeElements.length; i++) {
                  launcherTypeElements[i].addEventListener('click', function() {
                    for (var j = 0; j < launcherTypeElements.length; j++) {
                      launcherTypeElements[j].classList.remove('active');
                    }
                    this.classList.add('active');
                    if ( this.classList.contains('launcher-private') ) {
                      localStorage.launcherType = 'launcher-private';
                    } else if ( this.classList.contains('launcher-public') ) {
                      localStorage.launcherType = 'launcher-public';
                    }
                    setLaunchServer();
                  })
                }
                const launcherPublic = document.getElementById('launcher-public-input');
                const launcherPrivate = document.getElementById('launcher-private-input');
                const pageName = "match_transport";
                const repoURL = "https://github.com/QuantEcon/lecture-python-advanced.notebooks";
                const urlPath = "tree/lecture-python-advanced.notebooks/match_transport.ipynb";
                const branch = "main"
                const launchNotebookLink = document.getElementById('advancedLaunchButton');

                // Highlight public server option if previous selection exists
                if (typeof localStorage.launcherPublic !== 'undefined') {
                  launcherPublic.value = localStorage.launcherPublic;
                }
                // Update local storage upon public server selection
                launcherPublic.addEventListener('change', (event) => {
                  setLaunchServer();
                });
                // Populate private server input if previous entry exists
                if (typeof localStorage.launcherPrivate !== 'undefined') {
                  launcherPrivate.value = localStorage.launcherPrivate;
                }
                // Update local storage when a private server is entered
                launcherPrivate.addEventListener('input', (event) => {
                  setLaunchServer();
                });

                // Function to update the "Launch Notebook" link href
                function setLaunchServer() {
                  launchNotebookLink.removeAttribute("style")
                  if ( localStorage.launcherType == 'launcher-private' ) {
                    let repoPrefix = "/jupyter/hub/user-redirect/git-pull?repo=" + repoURL + "&branch=" + branch + "&urlpath=" + urlPath;
                    launcherPrivateValue = launcherPrivate.value
                    if (!launcherPrivateValue) {
                        launchNotebookLink.removeAttribute("href")
                        launchNotebookLink.style.background = "grey"
                        return
                    }
                    localStorage.launcherPrivate = launcherPrivateValue;
                    privateServer = localStorage.launcherPrivate.replace(/\/$/, "")
                    if (!privateServer.includes("http")) {
                        privateServer = "http://" + privateServer
                    }
                    launchNotebookLinkURL = privateServer + repoPrefix;
                  } else if ( localStorage.launcherType == 'launcher-public' ) {
                    launcherPublicValue = launcherPublic.options[launcherPublic.selectedIndex].value;
                    localStorage.launcherPublic = launcherPublicValue;
                    launchNotebookLinkURL = localStorage.launcherPublic;
                  }
                  if (launchNotebookLinkURL) launchNotebookLink.href = launchNotebookLinkURL;
                }
                // Check if user has previously selected a server
                if ( (typeof localStorage.launcherPrivate !== 'undefined') || (typeof localStorage.launcherPublic !== 'undefined') ) {
                  setLaunchServer();
                }
                </script>

        </div>

    </div> <!-- .wrapper-->
  </body>
</html>